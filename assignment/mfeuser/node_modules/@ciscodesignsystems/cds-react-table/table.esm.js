import { forwardRef, useState, useCallback, useRef, useLayoutEffect, Fragment, useMemo } from 'react';
import { DndProvider } from 'react-dnd';
import { HTML5Backend } from 'react-dnd-html5-backend';
import { useReactTable, getExpandedRowModel, getSortedRowModel, getCoreRowModel, getFilteredRowModel, getPaginationRowModel } from '@tanstack/react-table';
import { cx } from '@ciscodesignsystems/cds-component-utilities';
import { CDSFlex } from '@ciscodesignsystems/cds-react-flex';
import { CDSTableBulkActionBar } from './components/table-bulk-action-bar/table-bulk-action-bar.esm.js';
import { CDSTableEmptyRow } from './components/table-empty-row/table-empty-row.esm.js';
import { EmptyStateInfo } from './components/table-empty/empty-state-info.esm.js';
import { CDSTableFilterBar } from './components/table-filter-bar/table-filter-bar.esm.js';
import { TableHeader } from './components/table-header/table-header.esm.js';
import { TableHeaderDraggable } from './components/table-header/table-header-draggable.esm.js';
import { CDSTableLoadingRows } from './components/table-loading-rows/table-loading-rows.esm.js';
import { CDSTablePagination } from './components/table-pagination/table-pagination.esm.js';
import { TableRow } from './components/table-row/table-row.esm.js';
import { TableRowDraggable } from './components/table-row/table-row-draggable.esm.js';
import { TableRowExpanded } from './components/table-row/table-row-expanded.esm.js';
import { CDSTableConfiguration } from './components/table-settings/table-settings.esm.js';
import { TableContext } from './context/index.esm.js';
import { fuzzyFilterFn } from './filter-functions/fuzzy-filter-fn.esm.js';
import { EXCLUDED_COLUMNS } from './util/constants.esm.js';
import { useColumnOrder } from './util/hooks/useColumnOrder.esm.js';
import { useColumnPinning } from './util/hooks/useColumnPinning.esm.js';
import { useColumnVisibility } from './util/hooks/useColumnVisibility.esm.js';
import { useColumns } from './util/hooks/useColumns.esm.js';
import styles from './table.module.esm.js';
import { jsx, jsxs } from 'react/jsx-runtime';

const CDSTableComponent = ({
  columns: columnsFromProps,
  data,
  size = undefined,
  sticky = false,
  rowSelection = undefined,
  onRowSelectionChange = undefined,
  pagination = false,
  paginationConfig = {
    pageSize: 30,
    showPageSizeChanger: true,
    pageSizeOptions: [30, 50, 100]
  },
  enablePinning: enablePinningFromProps = false,
  columnPinningState = {
    left: [],
    right: []
  },
  actionBarConfig = {},
  className = undefined,
  paginationClassName = undefined,
  columnFilters = undefined,
  children = null,
  enableColumnsDisplaySettings = false,
  displaySettingsColumnDef = undefined,
  enableSortColumns = false,
  enableReorderRows = false,
  onReorderRow = undefined,
  manualPagination = false,
  onSortingChange = undefined,
  loading = false,
  emptyStateMessage = 'No matches found',
  emptyState = undefined,
  enableExpanding = false,
  rowExpansionConfig = undefined,
  onRowClick = undefined,
  ...rest
}, ref) => {
  if (!!rowSelection !== !!onRowSelectionChange) {
    throw new Error('Incorrect usage: selection and onSelectionChange are required together');
  }
  const selectable = !!rowSelection || !!onRowSelectionChange;
  const expandable = !!enableExpanding || !!rowExpansionConfig;
  const selectedItemCount = Object.keys(rowSelection ?? {}).length;
  const [sorting, setSorting] = useState([]);
  const [globalFilter, setGlobalFilter] = useState('');
  const [isColumnsSettingsOpen, setColumnsSettingsOpen] = useState(false);
  const toggleColumnSettingsDrawer = useCallback(() => {
    setColumnsSettingsOpen(prev => !prev);
  }, [setColumnsSettingsOpen]);
  const {
    enablePinning,
    columnPinning,
    setColumnPinning
  } = useColumnPinning({
    enablePinning: enablePinningFromProps,
    columnPinning: columnPinningState,
    enableReorderRows,
    expandable,
    selectable,
    enableColumnsDisplaySettings
  });
  const {
    columnVisibility,
    setColumnVisibility
  } = useColumnVisibility({
    columns: columnsFromProps
  });
  const columns = useColumns({
    enableReorderRows,
    expandable,
    selectable,
    columns: columnsFromProps,
    enableColumnsDisplaySettings,
    displaySettingsColumnDef,
    displaySettingsOnClick: () => toggleColumnSettingsDrawer(),
    size
  });
  const {
    columnOrder,
    setColumnOrder
  } = useColumnOrder({
    columnPinning: columnPinningState,
    columns
  });
  const classes = cx(styles, 'cds-table', {
    'cds-table--sticky': sticky,
    'cds-table--selectable': selectable,
    'cds-table--loading': loading,
    [`cds-table--${size}`]: size
  }, className);
  const onSortingChangeCallback = useCallback(updater => {
    return setSorting(prev => {
      const updatedValue = typeof updater === 'function' ? updater(prev) : updater;
      onSortingChange?.(updatedValue);
      return updatedValue;
    });
  }, [onSortingChange]);
  const table = useReactTable({
    data,
    columns,
    filterFns: {
      fuzzy: fuzzyFilterFn
    },
    ...(manualPagination ? {
      pageCount: paginationConfig?.pageCount
    } : {}),
    state: {
      columnOrder,
      sorting,
      ...(selectable ? {
        rowSelection
      } : {}),
      ...(columnFilters ? {
        columnFilters
      } : {}),
      ...(!manualPagination ? {
        globalFilter
      } : {}),
      columnVisibility,
      ...(manualPagination ? {
        pagination: paginationConfig?.paginationState
      } : {}),
      ...(enablePinning ? {
        columnPinning
      } : {})
    },
    initialState: {
      pagination: {
        pageSize: pagination && paginationConfig ? paginationConfig.pageSize : 30
      }
    },
    ...(expandable ? {
      enableExpanding
    } : {}),
    getRowCanExpand: rowExpansionConfig?.getRowCanExpand,
    getExpandedRowModel: getExpandedRowModel(),
    onColumnOrderChange: setColumnOrder,
    onColumnVisibilityChange: setColumnVisibility,
    ...(!manualPagination ? {
      onGlobalFilterChange: setGlobalFilter,
      globalFilterFn: fuzzyFilterFn
    } : {}),
    onSortingChange: onSortingChangeCallback,
    getSortedRowModel: getSortedRowModel(),
    ...(selectable ? {
      onRowSelectionChange
    } : {}),
    getCoreRowModel: getCoreRowModel(),
    getFilteredRowModel: getFilteredRowModel(),
    ...(pagination ? {
      getPaginationRowModel: !manualPagination ? getPaginationRowModel() : undefined
    } : {}),
    ...(manualPagination ? {
      onPaginationChange: paginationConfig?.onPaginationChange
    } : {}),
    manualPagination,
    manualSorting: manualPagination,
    enablePinning,
    ...(enablePinning ? {
      onColumnPinningChange: setColumnPinning
    } : {}),
    getRowId: paginationConfig?.getRowId
  });
  const [columnSizes, setColumnSizes] = useState({});
  const headerRefs = useRef({});
  const getPinnedColumnKey = useCallback(header => {
    return `${header.column.getIsPinned()}-${header.column.getPinnedIndex()}`;
  }, []);
  const getPinnedColumnSizes = useCallback(sizes => {
    return sizes.slice(0, -1).reduce((acc, curr, index) => {
      const runningSum = acc[index] + curr;
      return [...acc, runningSum];
    }, [0]);
  }, []);
  const getPinnedPositions = useCallback(() => {
    const columnSizeMapper = header => columnSizes[getPinnedColumnKey(header)];
    const leftColumnSizes = getPinnedColumnSizes(table.getLeftFlatHeaders().map(columnSizeMapper));
    const rightColumnSizes = getPinnedColumnSizes(table.getRightFlatHeaders().map(columnSizeMapper).reverse()).reverse();
    return {
      left: [...leftColumnSizes],
      right: [...rightColumnSizes]
    };
  }, [columnSizes, getPinnedColumnKey, getPinnedColumnSizes, table]);
  useLayoutEffect(() => {
    const observers = Object.entries(headerRefs.current).map(([id, element]) => {
      if (!element) {
        return undefined;
      }
      const observer = new ResizeObserver(() => {
        setColumnSizes(prev => ({
          ...prev,
          [id]: element.getBoundingClientRect().width
        }));
      });
      observer.observe(element);
      return observer;
    });
    return () => {
      observers.forEach(observer => observer?.disconnect());
    };
  }, [loading]);
  const onRowClickHandler = onRowClick && !enableReorderRows && !selectable && !expandable && !table.getCanSomeRowsExpand() ? onRowClick : undefined;
  const renderTableHeaders = useCallback(() => {
    const pinnedPositions = getPinnedPositions();
    return table.getHeaderGroups().map(headerGroup => /*#__PURE__*/jsx("tr", {
      children: headerGroup.headers.map(header => {
        const isPinned = header.column.getIsPinned();
        const pinnedIndex = header.column.getPinnedIndex();
        const pinnedPosition = isPinned !== false ? pinnedPositions[isPinned][pinnedIndex] : undefined;
        return enableSortColumns && !loading && !EXCLUDED_COLUMNS.includes(header.column.id) ? /*#__PURE__*/jsx(TableHeaderDraggable, {
          header: header,
          pinnedPosition: pinnedPosition,
          ref: element => headerRefs.current[getPinnedColumnKey(header)] = element
        }, header.id) : /*#__PURE__*/jsx(TableHeader, {
          header: header,
          ref: element => headerRefs.current[getPinnedColumnKey(header)] = element,
          loading: loading,
          pinnedPosition: pinnedPosition
        }, header.id);
      })
    }, headerGroup.id));
  }, [getPinnedPositions, table, enableSortColumns, loading, getPinnedColumnKey]);
  const DefaultEmptyState = useCallback(() => /*#__PURE__*/jsx(CDSFlex, {
    align: "center",
    direction: "vertical",
    children: /*#__PURE__*/jsx(EmptyStateInfo, {
      width: 85,
      height: 75,
      message: emptyStateMessage
    })
  }), [emptyStateMessage]);
  const renderTableRows = useCallback(() => {
    if (loading) {
      return /*#__PURE__*/jsx(CDSTableLoadingRows, {
        rows: 10,
        columns: columns.length
      });
    } else if (table.getRowModel().rows.length === 0) {
      return /*#__PURE__*/jsx(CDSTableEmptyRow, {
        colSpan: columns.length,
        emptyState: emptyState ?? /*#__PURE__*/jsx(DefaultEmptyState, {})
      });
    }
    return table.getRowModel().rows.map(row => {
      return /*#__PURE__*/jsxs(Fragment, {
        children: [enableReorderRows && onReorderRow ? /*#__PURE__*/jsx(TableRowDraggable, {
          table: table,
          row: row,
          onReorderRow: onReorderRow
        }, row.id) : /*#__PURE__*/jsx(TableRow, {
          row: row,
          pinnedPositions: getPinnedPositions(),
          onClick: onRowClickHandler ? event => onRowClickHandler?.(event, row) : undefined
        }), row.getCanExpand() && row.getIsExpanded() && /*#__PURE__*/jsx(TableRowExpanded, {
          row: row,
          children: rowExpansionConfig?.expandedRowRender(row)
        })]
      }, row.id);
    });
  }, [table, loading, emptyState, DefaultEmptyState, getPinnedPositions, rowExpansionConfig, enableReorderRows, onReorderRow, onRowClickHandler, columns]);
  const tableContextValue = useMemo(() => ({
    globalFilter,
    setGlobalFilter,
    table,
    manualPagination
  }), [globalFilter, setGlobalFilter, table, manualPagination]);
  return /*#__PURE__*/jsxs(TableContext.Provider, {
    value: tableContextValue,
    children: [children, selectedItemCount > 0 && /*#__PURE__*/jsx(CDSTableBulkActionBar, {
      ...actionBarConfig,
      selectedItemCount: selectedItemCount,
      onSelectAllItems: () => table.toggleAllRowsSelected(true),
      onCancelSelection: () => table.toggleAllRowsSelected(false)
    }), /*#__PURE__*/jsx(DndProvider, {
      backend: HTML5Backend,
      children: /*#__PURE__*/jsx(CDSFlex, {
        className: cx(styles, 'cds-table-wrapper'),
        children: /*#__PURE__*/jsxs("table", {
          ...rest,
          className: classes,
          ref: ref,
          children: [/*#__PURE__*/jsx("thead", {
            children: renderTableHeaders()
          }), /*#__PURE__*/jsx("tbody", {
            children: renderTableRows()
          })]
        })
      })
    }), table.getRowModel().rows.length > 0 && pagination !== false && paginationConfig && /*#__PURE__*/jsx(CDSTablePagination, {
      className: paginationClassName,
      table: table,
      paginationConfig: paginationConfig
    }), enableColumnsDisplaySettings !== false && /*#__PURE__*/jsx(CDSTableConfiguration, {
      table: table,
      onClose: toggleColumnSettingsDrawer,
      onOpen: toggleColumnSettingsDrawer,
      isOpen: isColumnsSettingsOpen
    })]
  });
};
const CDSTableForwardComponent = /*#__PURE__*/forwardRef(CDSTableComponent);
const CDSTableNamespace = Object.assign(CDSTableForwardComponent, {
  FilterBar: CDSTableFilterBar
});

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
CDSTableNamespace.displayName = 'CDSTable';

export { CDSTableNamespace as CDSTable, CDSTableNamespace as default };
