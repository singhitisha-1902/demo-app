'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jsxRuntime = require('react/jsx-runtime');
var react = require('react');
var reactDnd = require('react-dnd');
var reactDndHtml5Backend = require('react-dnd-html5-backend');
var reactTable = require('@tanstack/react-table');
var cdsComponentUtilities = require('@ciscodesignsystems/cds-component-utilities');
var cdsReactFlex = require('@ciscodesignsystems/cds-react-flex');
var tableBulkActionBar = require('./components/table-bulk-action-bar/table-bulk-action-bar.cjs.js');
var tableEmptyRow = require('./components/table-empty-row/table-empty-row.cjs.js');
var emptyStateInfo = require('./components/table-empty/empty-state-info.cjs.js');
var tableFilterBar = require('./components/table-filter-bar/table-filter-bar.cjs.js');
var tableHeader = require('./components/table-header/table-header.cjs.js');
var tableHeaderDraggable = require('./components/table-header/table-header-draggable.cjs.js');
var tableLoadingRows = require('./components/table-loading-rows/table-loading-rows.cjs.js');
var tablePagination = require('./components/table-pagination/table-pagination.cjs.js');
var tableRow = require('./components/table-row/table-row.cjs.js');
var tableRowDraggable = require('./components/table-row/table-row-draggable.cjs.js');
var tableRowExpanded = require('./components/table-row/table-row-expanded.cjs.js');
var tableSettings = require('./components/table-settings/table-settings.cjs.js');
var index = require('./context/index.cjs.js');
var fuzzyFilterFn = require('./filter-functions/fuzzy-filter-fn.cjs.js');
var constants = require('./util/constants.cjs.js');
var useColumnOrder = require('./util/hooks/useColumnOrder.cjs.js');
var useColumnPinning = require('./util/hooks/useColumnPinning.cjs.js');
var useColumnVisibility = require('./util/hooks/useColumnVisibility.cjs.js');
var useColumns = require('./util/hooks/useColumns.cjs.js');
var table_module = require('./table.module.cjs.js');

const CDSTableComponent = ({
  columns: columnsFromProps,
  data,
  size = undefined,
  sticky = false,
  rowSelection = undefined,
  onRowSelectionChange = undefined,
  pagination = false,
  paginationConfig = {
    pageSize: 30,
    showPageSizeChanger: true,
    pageSizeOptions: [30, 50, 100]
  },
  enablePinning: enablePinningFromProps = false,
  columnPinningState = {
    left: [],
    right: []
  },
  actionBarConfig = {},
  className = undefined,
  paginationClassName = undefined,
  columnFilters = undefined,
  children = null,
  enableColumnsDisplaySettings = false,
  displaySettingsColumnDef = undefined,
  enableSortColumns = false,
  enableReorderRows = false,
  onReorderRow = undefined,
  manualPagination = false,
  onSortingChange = undefined,
  loading = false,
  emptyStateMessage = 'No matches found',
  emptyState = undefined,
  enableExpanding = false,
  rowExpansionConfig = undefined,
  onRowClick = undefined,
  ...rest
}, ref) => {
  if (!!rowSelection !== !!onRowSelectionChange) {
    throw new Error('Incorrect usage: selection and onSelectionChange are required together');
  }
  const selectable = !!rowSelection || !!onRowSelectionChange;
  const expandable = !!enableExpanding || !!rowExpansionConfig;
  const selectedItemCount = Object.keys(rowSelection !== null && rowSelection !== void 0 ? rowSelection : {}).length;
  const [sorting, setSorting] = react.useState([]);
  const [globalFilter, setGlobalFilter] = react.useState('');
  const [isColumnsSettingsOpen, setColumnsSettingsOpen] = react.useState(false);
  const toggleColumnSettingsDrawer = react.useCallback(() => {
    setColumnsSettingsOpen(prev => !prev);
  }, [setColumnsSettingsOpen]);
  const {
    enablePinning,
    columnPinning,
    setColumnPinning
  } = useColumnPinning.useColumnPinning({
    enablePinning: enablePinningFromProps,
    columnPinning: columnPinningState,
    enableReorderRows,
    expandable,
    selectable,
    enableColumnsDisplaySettings
  });
  const {
    columnVisibility,
    setColumnVisibility
  } = useColumnVisibility.useColumnVisibility({
    columns: columnsFromProps
  });
  const columns = useColumns.useColumns({
    enableReorderRows,
    expandable,
    selectable,
    columns: columnsFromProps,
    enableColumnsDisplaySettings,
    displaySettingsColumnDef,
    displaySettingsOnClick: () => toggleColumnSettingsDrawer(),
    size
  });
  const {
    columnOrder,
    setColumnOrder
  } = useColumnOrder.useColumnOrder({
    columnPinning: columnPinningState,
    columns
  });
  const classes = cdsComponentUtilities.cx(table_module["default"], 'cds-table', {
    'cds-table--sticky': sticky,
    'cds-table--selectable': selectable,
    'cds-table--loading': loading,
    [`cds-table--${size}`]: size
  }, className);
  const onSortingChangeCallback = react.useCallback(updater => {
    return setSorting(prev => {
      const updatedValue = typeof updater === 'function' ? updater(prev) : updater;
      onSortingChange === null || onSortingChange === void 0 ? void 0 : onSortingChange(updatedValue);
      return updatedValue;
    });
  }, [onSortingChange]);
  const table = reactTable.useReactTable({
    data,
    columns,
    filterFns: {
      fuzzy: fuzzyFilterFn.fuzzyFilterFn
    },
    ...(manualPagination ? {
      pageCount: paginationConfig === null || paginationConfig === void 0 ? void 0 : paginationConfig.pageCount
    } : {}),
    state: {
      columnOrder,
      sorting,
      ...(selectable ? {
        rowSelection
      } : {}),
      ...(columnFilters ? {
        columnFilters
      } : {}),
      ...(!manualPagination ? {
        globalFilter
      } : {}),
      columnVisibility,
      ...(manualPagination ? {
        pagination: paginationConfig === null || paginationConfig === void 0 ? void 0 : paginationConfig.paginationState
      } : {}),
      ...(enablePinning ? {
        columnPinning
      } : {})
    },
    initialState: {
      pagination: {
        pageSize: pagination && paginationConfig ? paginationConfig.pageSize : 30
      }
    },
    ...(expandable ? {
      enableExpanding
    } : {}),
    getRowCanExpand: rowExpansionConfig === null || rowExpansionConfig === void 0 ? void 0 : rowExpansionConfig.getRowCanExpand,
    getExpandedRowModel: reactTable.getExpandedRowModel(),
    onColumnOrderChange: setColumnOrder,
    onColumnVisibilityChange: setColumnVisibility,
    ...(!manualPagination ? {
      onGlobalFilterChange: setGlobalFilter,
      globalFilterFn: fuzzyFilterFn.fuzzyFilterFn
    } : {}),
    onSortingChange: onSortingChangeCallback,
    getSortedRowModel: reactTable.getSortedRowModel(),
    ...(selectable ? {
      onRowSelectionChange
    } : {}),
    getCoreRowModel: reactTable.getCoreRowModel(),
    getFilteredRowModel: reactTable.getFilteredRowModel(),
    ...(pagination ? {
      getPaginationRowModel: !manualPagination ? reactTable.getPaginationRowModel() : undefined
    } : {}),
    ...(manualPagination ? {
      onPaginationChange: paginationConfig === null || paginationConfig === void 0 ? void 0 : paginationConfig.onPaginationChange
    } : {}),
    manualPagination,
    manualSorting: manualPagination,
    enablePinning,
    ...(enablePinning ? {
      onColumnPinningChange: setColumnPinning
    } : {}),
    getRowId: paginationConfig === null || paginationConfig === void 0 ? void 0 : paginationConfig.getRowId
  });
  const [columnSizes, setColumnSizes] = react.useState({});
  const headerRefs = react.useRef({});
  const getPinnedColumnKey = react.useCallback(header => {
    return `${header.column.getIsPinned()}-${header.column.getPinnedIndex()}`;
  }, []);
  const getPinnedColumnSizes = react.useCallback(sizes => {
    return sizes.slice(0, -1).reduce((acc, curr, index) => {
      const runningSum = acc[index] + curr;
      return [...acc, runningSum];
    }, [0]);
  }, []);
  const getPinnedPositions = react.useCallback(() => {
    const columnSizeMapper = header => columnSizes[getPinnedColumnKey(header)];
    const leftColumnSizes = getPinnedColumnSizes(table.getLeftFlatHeaders().map(columnSizeMapper));
    const rightColumnSizes = getPinnedColumnSizes(table.getRightFlatHeaders().map(columnSizeMapper).reverse()).reverse();
    return {
      left: [...leftColumnSizes],
      right: [...rightColumnSizes]
    };
  }, [columnSizes, getPinnedColumnKey, getPinnedColumnSizes, table]);
  react.useLayoutEffect(() => {
    const observers = Object.entries(headerRefs.current).map(([id, element]) => {
      if (!element) {
        return undefined;
      }
      const observer = new ResizeObserver(() => {
        setColumnSizes(prev => ({
          ...prev,
          [id]: element.getBoundingClientRect().width
        }));
      });
      observer.observe(element);
      return observer;
    });
    return () => {
      observers.forEach(observer => observer === null || observer === void 0 ? void 0 : observer.disconnect());
    };
  }, [loading]);
  const onRowClickHandler = onRowClick && !enableReorderRows && !selectable && !expandable && !table.getCanSomeRowsExpand() ? onRowClick : undefined;
  const renderTableHeaders = react.useCallback(() => {
    const pinnedPositions = getPinnedPositions();
    return table.getHeaderGroups().map(headerGroup => jsxRuntime.jsx("tr", {
      children: headerGroup.headers.map(header => {
        const isPinned = header.column.getIsPinned();
        const pinnedIndex = header.column.getPinnedIndex();
        const pinnedPosition = isPinned !== false ? pinnedPositions[isPinned][pinnedIndex] : undefined;
        return enableSortColumns && !loading && !constants.EXCLUDED_COLUMNS.includes(header.column.id) ? jsxRuntime.jsx(tableHeaderDraggable.TableHeaderDraggable, {
          header: header,
          pinnedPosition: pinnedPosition,
          ref: element => headerRefs.current[getPinnedColumnKey(header)] = element
        }, header.id) : jsxRuntime.jsx(tableHeader.TableHeader, {
          header: header,
          ref: element => headerRefs.current[getPinnedColumnKey(header)] = element,
          loading: loading,
          pinnedPosition: pinnedPosition
        }, header.id);
      })
    }, headerGroup.id));
  }, [getPinnedPositions, table, enableSortColumns, loading, getPinnedColumnKey]);
  const DefaultEmptyState = react.useCallback(() => jsxRuntime.jsx(cdsReactFlex.CDSFlex, {
    align: "center",
    direction: "vertical",
    children: jsxRuntime.jsx(emptyStateInfo.EmptyStateInfo, {
      width: 85,
      height: 75,
      message: emptyStateMessage
    })
  }), [emptyStateMessage]);
  const renderTableRows = react.useCallback(() => {
    if (loading) {
      return jsxRuntime.jsx(tableLoadingRows.CDSTableLoadingRows, {
        rows: 10,
        columns: columns.length
      });
    } else if (table.getRowModel().rows.length === 0) {
      return jsxRuntime.jsx(tableEmptyRow.CDSTableEmptyRow, {
        colSpan: columns.length,
        emptyState: emptyState !== null && emptyState !== void 0 ? emptyState : jsxRuntime.jsx(DefaultEmptyState, {})
      });
    }
    return table.getRowModel().rows.map(row => {
      return jsxRuntime.jsxs(react.Fragment, {
        children: [enableReorderRows && onReorderRow ? jsxRuntime.jsx(tableRowDraggable.TableRowDraggable, {
          table: table,
          row: row,
          onReorderRow: onReorderRow
        }, row.id) : jsxRuntime.jsx(tableRow.TableRow, {
          row: row,
          pinnedPositions: getPinnedPositions(),
          onClick: onRowClickHandler ? event => onRowClickHandler === null || onRowClickHandler === void 0 ? void 0 : onRowClickHandler(event, row) : undefined
        }), row.getCanExpand() && row.getIsExpanded() && jsxRuntime.jsx(tableRowExpanded.TableRowExpanded, {
          row: row,
          children: rowExpansionConfig === null || rowExpansionConfig === void 0 ? void 0 : rowExpansionConfig.expandedRowRender(row)
        })]
      }, row.id);
    });
  }, [table, loading, emptyState, DefaultEmptyState, getPinnedPositions, rowExpansionConfig, enableReorderRows, onReorderRow, onRowClickHandler, columns]);
  const tableContextValue = react.useMemo(() => ({
    globalFilter,
    setGlobalFilter,
    table,
    manualPagination
  }), [globalFilter, setGlobalFilter, table, manualPagination]);
  return jsxRuntime.jsxs(index.TableContext.Provider, {
    value: tableContextValue,
    children: [children, selectedItemCount > 0 && jsxRuntime.jsx(tableBulkActionBar.CDSTableBulkActionBar, {
      ...actionBarConfig,
      selectedItemCount: selectedItemCount,
      onSelectAllItems: () => table.toggleAllRowsSelected(true),
      onCancelSelection: () => table.toggleAllRowsSelected(false)
    }), jsxRuntime.jsx(reactDnd.DndProvider, {
      backend: reactDndHtml5Backend.HTML5Backend,
      children: jsxRuntime.jsx(cdsReactFlex.CDSFlex, {
        className: cdsComponentUtilities.cx(table_module["default"], 'cds-table-wrapper'),
        children: jsxRuntime.jsxs("table", {
          ...rest,
          className: classes,
          ref: ref,
          children: [jsxRuntime.jsx("thead", {
            children: renderTableHeaders()
          }), jsxRuntime.jsx("tbody", {
            children: renderTableRows()
          })]
        })
      })
    }), table.getRowModel().rows.length > 0 && pagination !== false && paginationConfig && jsxRuntime.jsx(tablePagination.CDSTablePagination, {
      className: paginationClassName,
      table: table,
      paginationConfig: paginationConfig
    }), enableColumnsDisplaySettings !== false && jsxRuntime.jsx(tableSettings.CDSTableConfiguration, {
      table: table,
      onClose: toggleColumnSettingsDrawer,
      onOpen: toggleColumnSettingsDrawer,
      isOpen: isColumnsSettingsOpen
    })]
  });
};
const CDSTableForwardComponent = /*#__PURE__*/react.forwardRef(CDSTableComponent);
const CDSTableNamespace = Object.assign(CDSTableForwardComponent, {
  FilterBar: tableFilterBar.CDSTableFilterBar
});
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
CDSTableNamespace.displayName = 'CDSTable';

exports.CDSTable = CDSTableNamespace;
exports["default"] = CDSTableNamespace;
