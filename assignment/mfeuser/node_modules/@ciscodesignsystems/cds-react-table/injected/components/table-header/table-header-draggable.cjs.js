'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jsxRuntime = require('react/jsx-runtime');
var react = require('react');
var reactDnd = require('react-dnd');
var cdsComponentTypes = require('@ciscodesignsystems/cds-component-types');
var cdsComponentUtilities = require('@ciscodesignsystems/cds-component-utilities');
var tableHeader = require('./table-header.cjs.js');
var tableHeaderDraggable_module = require('./table-header-draggable.module.cjs.js');

const reorderColumn = (draggedColumnId, targetColumnId, columnOrder) => {
  columnOrder.splice(columnOrder.indexOf(targetColumnId), 0, columnOrder.splice(columnOrder.indexOf(draggedColumnId), 1)[0]);
  return [...columnOrder];
};
const TableHeaderDraggableComponent = ({
  header,
  ...rest
}, ref) => {
  const {
    table
  } = header.getContext();
  const {
    getState,
    setColumnOrder
  } = table;
  const {
    columnOrder
  } = getState();
  const {
    column
  } = header;
  const canOrder = table.getIsSomeColumnsPinned() ? column.getCanPin() && column.getIsPinned() === false : true;
  const [{
    isOverCurrent,
    canDrop,
    dropZoneSide
  }, dropRef] = reactDnd.useDrop({
    accept: 'column',
    drop: draggedColumn => {
      const isColumnPinned = column.getIsPinned();
      const canPinDraggedColumn = draggedColumn.getCanPin();
      if (isColumnPinned !== false && canPinDraggedColumn) {
        draggedColumn.pin(isColumnPinned);
        return;
      }
      const newColumnOrder = reorderColumn(draggedColumn.id, column.id, columnOrder);
      setColumnOrder(newColumnOrder);
    },
    collect: monitor => {
      var _a;
      return {
        canDrop: monitor.canDrop(),
        isOverCurrent: monitor.isOver({
          shallow: true
        }),
        dropZoneSide: columnOrder.indexOf((_a = monitor.getItem()) === null || _a === void 0 ? void 0 : _a.id) > columnOrder.indexOf(column.id) ? 'left' : 'right'
      };
    },
    canDrop: () => true
  });
  const [{
    isDragging
  }, dragRef, previewRef] = reactDnd.useDrag({
    collect: monitor => ({
      isDragging: monitor.isDragging()
    }),
    item: () => column,
    type: 'column',
    canDrag: () => canOrder
  });
  const mergedRefs = cdsComponentTypes.useMergeRefs([ref, dragRef, dropRef, previewRef]);
  const draggableHeaderClasses = cdsComponentUtilities.cx(tableHeaderDraggable_module["default"], {
    'cds-table__header--draggable': canOrder,
    'cds-table__header--draggable--is-dragging': isDragging,
    [`cds-table__header--not-droppable`]: isOverCurrent && !canDrop,
    [`cds-table__header--droppable--${dropZoneSide}`]: isOverCurrent && canDrop
  });
  return jsxRuntime.jsx(tableHeader.TableHeader, {
    ...rest,
    ref: mergedRefs,
    className: draggableHeaderClasses,
    header: header
  });
};
const TableHeaderDraggable = /*#__PURE__*/react.forwardRef(TableHeaderDraggableComponent);

exports.TableHeaderDraggable = TableHeaderDraggable;
exports.TableHeaderDraggableComponent = TableHeaderDraggableComponent;
