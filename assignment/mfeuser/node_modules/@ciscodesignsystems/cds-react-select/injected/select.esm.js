import { forwardRef, useState, useMemo, useEffect, useRef, Fragment as Fragment$1, createRef } from 'react';
import { useMergeRefs, FloatingPortal, FloatingFocusManager } from '@floating-ui/react';
import { X, XCircle, CaretDown, WarningOctagon } from 'phosphor-react';
import { cx } from '@ciscodesignsystems/cds-component-utilities';
import { CDSEmptyState } from '@ciscodesignsystems/cds-react-empty-state/injected';
import { CDSFlex } from '@ciscodesignsystems/cds-react-flex/injected';
import { CDSLabel } from '@ciscodesignsystems/cds-react-label/injected';
import { CDSTooltip } from '@ciscodesignsystems/cds-react-tooltip/injected';
import { CDSSelectAddItem } from './components/add-item/add-item.esm.js';
import { useFloatingSelect } from './use-floating-select.esm.js';
import { useSelectItems } from './use-select-items.esm.js';
import { useTypeahead } from './use-typeahead.esm.js';
import { handleBlurWhenFocusedOnOptionsDiv, tabIndex, getPlaceholder, handleClear, getSelectedValues } from './util/support-functions.esm.js';
import { truncateText, MIN_TRUNCATION_DEFAULT } from './util/truncated-text.esm.js';
import styles from './select.module.esm.js';
import { jsx, jsxs, Fragment } from 'react/jsx-runtime';
import { CDSSelectItem } from './components/item/select-item.esm.js';

const focus = {
  triggerManualFocus: false
};
const getTooltipLabel = (selectedOptions, multiple) => {
  return selectedOptions?.map(option => {
    return option.label;
  }).join(multiple ? ', ' : '');
};
const getSelectedLabels = (selectedOptions, multiple) => {
  return selectedOptions?.map(option => {
    return option.label;
  }).join(multiple ? ',' : '');
};
const CDSSelect = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    id,
    icon,
    label,
    options: optionsProp,
    multiple,
    clearable,
    disabled,
    name,
    placeholder,
    withTags,
    withAdd,
    withSearch,
    withCheck,
    size,
    value,
    onToggle,
    onChange,
    onSearch,
    onClear,
    onBlur,
    onAdd,
    onRemove,
    error,
    errorMessage,
    emptyStateMessage,
    required,
    optional,
    withTypeahead,
    infoMessage,
    isOpen: propOpen = false,
    className,
    withTruncatedTags,
    ...rest
  } = props;
  const [isFocused, setIsFocused] = useState(false);
  const [isMenuOpen, setIsMenuOpen] = useState(propOpen);
  const [inputValue, setInputValue] = useState('');
  const inputRef = /*#__PURE__*/createRef();
  const toggleRef = /*#__PURE__*/createRef();
  const options = useMemo(() => optionsProp.map(option => ({
    ...option
  })), [optionsProp]);
  useEffect(() => {
    setIsMenuOpen(propOpen);
  }, [propOpen]);
  const handleToggle = e => {
    setIsMenuOpen(e);
    onToggle?.(e);
  };
  const {
    removeOption,
    clearSearchValue,
    setSearchValue,
    clearSelected,
    updateSelect,
    selectOption,
    selectedOptions = [],
    filteredOptions,
    groupedOptions,
    hasOptionsGroups,
    addOption,
    deselectOption,
    getSelectedOptions
  } = useSelectItems({
    options: options,
    selectedOptions: [],
    filteredOptions: options,
    multiple
  });
  const previousOptions = useRef([]);
  useEffect(() => {
    if (JSON.stringify(previousOptions.current) !== JSON.stringify(options)) {
      updateSelect(options);
      previousOptions.current = options;
    }
  }, [updateSelect, options]);
  const suggestions = useTypeahead({
    inputValue,
    items: options,
    enabled: withTypeahead
  });
  const {
    x,
    y,
    strategy,
    refs,
    context,
    getFloatingProps,
    getItemProps,
    listRef,
    selectedIndex,
    activeIndex
  } = useFloatingSelect(isMenuOpen, handleToggle);
  const handleMultiSelect = item => {
    const selectedItems = getSelectedOptions();
    if (item.selected) {
      deselectOption(item);
      return selectedItems.filter(selectedItem => selectedItem.value !== item.value);
    }
    selectOption(item);
    handleToggle(true);
    return selectedItems.concat({
      ...item,
      selected: true
    });
  };
  const handleSelect = item => {
    if (multiple) {
      const selectedItems = handleMultiSelect(item);
      onChange?.(selectedItems);
    } else {
      clearSelected();
      selectOption(item);
      handleToggle(false);
      onChange?.({
        ...item,
        selected: true
      });
    }
    if ((withSearch || withTypeahead) && !multiple) {
      clearSearchValue();
      setInputValue('');
    }
  };
  const parentRef = useRef(null);
  const handleBlurWhenFocusedOnMainDiv = event => {
    if (!isMenuOpen) {
      onBlur?.(event);
    }
    setIsFocused(isMenuOpen);
    if (!inputValue) {
      setInputValue('');
      clearSearchValue();
    }
  };
  const handleFocus = () => {
    setIsFocused(true);
  };
  const handleOpen = (open = true) => {
    setIsMenuOpen(open);
    handleToggle(open);
    onToggle?.(open);
  };
  const handleRemove = option => {
    option.selected = !option.selected;
    onRemove?.(option);
    removeOption(option);
    handleOpen(false);
    onChange?.(getSelectedOptions());
  };
  const handleInputContainerClick = () => {
    if (withSearch) {
      inputRef.current?.focus();
    }
    handleToggle(!isMenuOpen);
  };
  const handleChange = event => {
    const value = event.target.value;
    setInputValue(value);
    handleToggle(Boolean(value));
    onSearch?.(value);
    setSearchValue(value);
  };
  const handleAddClick = () => {
    const opt = {
      selected: true,
      label: inputValue,
      value: inputValue
    };
    handleClear(setInputValue, clearSearchValue, clearSelected, inputRef, onClear, multiple);
    handleToggle(Boolean(multiple));
    addOption(opt);
    onAdd?.(opt);
  };
  const handleKeyDown = e => {
    if ((withSearch || withTypeahead) && inputValue === '' && e.key === 'Backspace') {
      return handleClear(setInputValue, clearSearchValue, clearSelected, inputRef, onClear);
    }
    if (e.key === 'Enter') {
      return;
    }
  };
  const getOptions = () => {
    if (inputValue && withTypeahead && suggestions) {
      return suggestions;
    } else if (hasOptionsGroups && (!withSearch || !inputValue)) {
      return groupedOptions;
    } else if (withSearch && inputValue && filteredOptions) {
      return filteredOptions;
    }
    return options;
  };
  const showSearchInput = withTypeahead || withSearch;
  const hasSelectedOptions = () => {
    return getSelectedOptions().length > 0;
  };
  const cdsSelectClassname = 'cds-select';
  const cdsSelectClasses = cx(styles, cdsSelectClassname, `${cdsSelectClassname}--${size}`, {
    [`${cdsSelectClassname}--show-search`]: showSearchInput,
    [`${cdsSelectClassname}--show-add`]: withAdd,
    [`${cdsSelectClassname}--show-tags`]: withTags,
    [`${cdsSelectClassname}--show-typeahead`]: withTypeahead,
    [`${cdsSelectClassname}--disabled`]: disabled,
    [`${cdsSelectClassname}--empty`]: !hasSelectedOptions(),
    [`cds-sentiment--negative`]: error
  }, className);
  const cdsSelectControlClasses = cx(styles, `${cdsSelectClassname}__control`, {
    [`${cdsSelectClassname}__control--focus`]: isFocused || isMenuOpen,
    [`${cdsSelectClassname}__control--show-search`]: isFocused && showSearchInput,
    [`${cdsSelectClassname}__control--open`]: isMenuOpen
  });
  const cdsSelectValueContainerClasses = cx(styles, `${cdsSelectClassname}__value-container`, {
    [`${cdsSelectClassname}__value-container--multiple--with-tag`]: multiple && withTags
  });
  const cdsSelectClassNames = (name, modifiers) => {
    return cx(styles, `${cdsSelectClassname}__${name}`, modifiers);
  };

  /**
   * Render individual option element.
   * @param {number} index The current index
   * @param {CDSOption} option The current option
   */
  function renderOptionElement(option, index) {
    const {
      onFocus,
      onMouseMove,
      onPointerLeave
    } = getItemProps();
    return /*#__PURE__*/jsx(CDSSelectItem, {
      ref: node => {
        listRef.current[index] = node;
      },
      withCheck: withCheck,
      size: size,
      multiple: multiple,
      option: option,
      onSelect: handleSelect,
      tabIndex: index === activeIndex ? 0 : -1,
      "aria-selected": option.selected || index === selectedIndex && index === activeIndex,
      onFocus: () => onFocus,
      onMouseMove: () => onMouseMove,
      onPointerLeave: () => onPointerLeave
    }, `${index}-${option.label}`);
  }
  useEffect(() => {
    handleBlurWhenFocusedOnOptionsDiv({
      isOpen: isMenuOpen,
      multiple,
      showSearchInput,
      focus,
      inputRef,
      parentRef
    });
  }, [inputRef, isMenuOpen, multiple, showSearchInput]);
  const renderError = () => /*#__PURE__*/jsxs("div", {
    className: cdsSelectClassNames('error'),
    "data-testid": 'cds-select-error',
    children: [/*#__PURE__*/jsx("span", {
      className: cdsSelectClassNames('error-icon'),
      children: /*#__PURE__*/jsx(WarningOctagon, {
        size: 20,
        weight: "fill"
      })
    }), /*#__PURE__*/jsx("span", {
      className: cdsSelectClassNames('error-message'),
      children: errorMessage
    })]
  });
  const renderLabel = (name, label, required, infoMessage, optional) => {
    return /*#__PURE__*/jsx(CDSLabel, {
      size: size,
      htmlFor: name,
      className: cx(styles, 'cds-label'),
      role: "none",
      title: label,
      required: required,
      optional: optional,
      infoMessage: infoMessage,
      onClick: () => {
        toggleRef.current?.focus();
      },
      children: label
    });
  };
  const placeholderMultipleSelectWithoutTags = placeholder && !withTags && !showSearchInput && label;
  const root = useRef(null);
  const mergedRefs = useMergeRefs([ref, root]);
  const getPlaceholderDiv = () => {
    if ((!multiple || withTags) && hasSelectedOptions()) return undefined;else if (placeholderMultipleSelectWithoutTags && !icon) return /*#__PURE__*/jsx("div", {
      className: cdsSelectClassNames('placeholder'),
      children: getPlaceholder({
        withSearch,
        withAdd,
        hasSelectedOptions,
        multiple,
        label,
        placeholder,
        withTags
      })
    });else if (placeholder && !showSearchInput) {
      return /*#__PURE__*/jsxs("div", {
        className: cdsSelectClassNames('placeholder'),
        children: [icon && /*#__PURE__*/jsx("span", {
          className: cdsSelectClassNames('value-icon'),
          children: icon
        }), getPlaceholder({
          withSearch,
          withAdd,
          hasSelectedOptions,
          multiple,
          label,
          placeholder,
          withTags
        })]
      });
    }
    return undefined;
  };
  const isTagTruncationTooltipDisabled = optionLabel => {
    if (withTruncatedTags) {
      return !!optionLabel && optionLabel.length <= (typeof withTruncatedTags === 'number' ? withTruncatedTags : MIN_TRUNCATION_DEFAULT);
    }
    return true;
  };
  return /*#__PURE__*/jsx("div", {
    className: cdsSelectClasses,
    ref: mergedRefs,
    ...rest,
    children: /*#__PURE__*/jsx(CDSFlex, {
      direction: "vertical",
      children: /*#__PURE__*/jsxs(Fragment, {
        children: [label && renderLabel(name, label, required, infoMessage, optional), /*#__PURE__*/jsxs("div", {
          className: cdsSelectControlClasses,
          onKeyDown: handleKeyDown,
          role: 'presentation',
          ...getFloatingProps(),
          ref: useMergeRefs([refs.setReference, parentRef]),
          onBlur: handleBlurWhenFocusedOnMainDiv,
          ...tabIndex(!!withSearch),
          "data-testid": 'cds-select-control',
          children: [/*#__PURE__*/jsxs("div", {
            className: cdsSelectValueContainerClasses,
            role: "none",
            children: [hasSelectedOptions() && !multiple && !inputValue && /*#__PURE__*/jsxs("div", {
              className: cdsSelectClassNames('value'),
              "data-testid": 'cds-select-value',
              onKeyDown: event => {
                if (event.key === 'Enter') {
                  event.preventDefault();
                  handleToggle(!isMenuOpen);
                }
              },
              onClick: () => handleToggle(!isMenuOpen),
              role: "none",
              children: [selectedOptions[0]?.icon && /*#__PURE__*/jsx("span", {
                className: cdsSelectClassNames('value-icon'),
                children: selectedOptions[0].icon
              }), /*#__PURE__*/jsx("span", {
                className: cdsSelectClassNames('value-label'),
                children: !inputValue && getSelectedLabels(selectedOptions, multiple)
              })]
            }), multiple && hasSelectedOptions() && (withTags ? /*#__PURE__*/jsx("ul", {
              className: cdsSelectClassNames('tags'),
              "data-testid": 'cds-select-tags',
              children: [...getSelectedOptions()].map(option => /*#__PURE__*/jsx(CDSTooltip, {
                autoPlacement: true,
                disabled: isTagTruncationTooltipDisabled(option.label),
                title: withTruncatedTags && option.label ? option.label : '',
                children: /*#__PURE__*/jsxs("li", {
                  className: cdsSelectClassNames('tag', !isTagTruncationTooltipDisabled(option.label) ? 'cds-select--truncated' : undefined),
                  children: [option?.icon && /*#__PURE__*/jsx("span", {
                    className: cdsSelectClassNames('value-icon'),
                    children: option.icon
                  }), /*#__PURE__*/jsx("span", {
                    className: cdsSelectClassNames('tag-label'),
                    children: withTruncatedTags ? truncateText(option.label, withTruncatedTags) : option.label
                  }), /*#__PURE__*/jsx("span", {
                    tabIndex: 0,
                    role: "button",
                    className: cdsSelectClassNames('tag-action'),
                    title: `Remove ${option.label}`,
                    onKeyDown: event => {
                      if (event.key === 'Enter') {
                        event.preventDefault();
                        handleRemove(option);
                      }
                    },
                    onClick: event => {
                      event.preventDefault();
                      handleRemove(option);
                    },
                    children: /*#__PURE__*/jsx(X, {
                      size: 14,
                      weight: "bold"
                    })
                  })]
                }, `tag-${option.label}`)
              }, `tag-${option.label}`))
            }) : /*#__PURE__*/jsx(CDSTooltip, {
              title: getTooltipLabel(selectedOptions, multiple),
              children: /*#__PURE__*/jsx("span", {
                className: cdsSelectClassNames('tag'),
                children: getSelectedOptions().length
              })
            }))]
          }), /*#__PURE__*/jsxs("div", {
            className: cdsSelectClassNames('input-container'),
            "data-testid": 'cds-select-input-container',
            role: "none",
            onClick: handleInputContainerClick,
            onKeyDown: event => {
              if (event.key === 'Enter') {
                event.preventDefault();
                handleInputContainerClick();
              }
            },
            children: [getPlaceholderDiv(), showSearchInput && /*#__PURE__*/jsx("input", {
              "data-testid": 'cds-select-input',
              className: cdsSelectClassNames('input'),
              type: "text",
              ref: inputRef,
              tabIndex: -1,
              value: inputValue,
              placeholder: String(getPlaceholder({
                withSearch,
                withAdd,
                hasSelectedOptions,
                multiple,
                label,
                placeholder,
                withTags
              })),
              onKeyDown: handleKeyDown,
              onFocus: handleFocus,
              onChange: handleChange
            })]
          }), /*#__PURE__*/jsxs("div", {
            className: cdsSelectClassNames('indicator-container'),
            children: [clearable && hasSelectedOptions() && /*#__PURE__*/jsx("button", {
              "data-testid": 'cds-select-indicator-clear',
              className: cdsSelectClassNames('indicator-clear'),
              type: 'button',
              "aria-label": 'Clear',
              onClick: () => handleClear(setInputValue, clearSearchValue, clearSelected, inputRef, onClear),
              children: /*#__PURE__*/jsx(XCircle, {
                size: 18
              })
            }), /*#__PURE__*/jsx("button", {
              "data-testid": 'cds-select-indicator-dropdown',
              className: cdsSelectClassNames('indicator-dropdown'),
              type: 'button',
              "aria-label": 'Open',
              "aria-expanded": isMenuOpen,
              ref: toggleRef,
              onClick: () => {
                handleToggle(!isMenuOpen);
              },
              children: /*#__PURE__*/jsx(CaretDown, {
                size: 18,
                weight: "bold"
              })
            })]
          }), /*#__PURE__*/jsx(FloatingPortal, {
            id: id,
            root: root.current,
            "data-testid": 'cds-select-portal',
            children: isMenuOpen && /*#__PURE__*/jsx(FloatingFocusManager, {
              context: context,
              modal: false,
              visuallyHiddenDismiss: true,
              initialFocus: withSearch || withTypeahead ? inputRef : -1,
              children: /*#__PURE__*/jsxs("div", {
                "data-testid": 'cds-select-menu',
                tabIndex: 0,
                onKeyDown: () => ({}),
                className: cdsSelectClassNames('menu', [`cds-select__menu--${size}`]),
                ref: refs.setFloating,
                role: "listbox",
                "aria-multiselectable": Boolean(multiple),
                onClick: () => focus.triggerManualFocus = true,
                style: {
                  position: strategy,
                  top: y ?? 0,
                  left: x ?? 0,
                  overflowY: 'auto',
                  boxSizing: 'border-box',
                  outline: 0
                },
                children: [options && !hasOptionsGroups && getOptions().map(renderOptionElement), hasOptionsGroups && getOptions().map((group, index) => {
                  return /*#__PURE__*/jsxs(Fragment$1, {
                    children: [/*#__PURE__*/jsx("div", {
                      className: cx(styles, 'cds-select__item cds-select__item--group'),
                      children: /*#__PURE__*/jsx("span", {
                        children: group.label
                      })
                    }), group.options.map(renderOptionElement)]
                  }, `group-${group.label}`);
                }), withAdd && inputValue && !hasOptionsGroups && /*#__PURE__*/jsx(CDSSelectAddItem, {
                  inputValue: inputValue,
                  handleAddClick: handleAddClick,
                  size: size
                }), !withAdd && getOptions().length === 0 && /*#__PURE__*/jsx("div", {
                  className: cdsSelectClassNames('empty-state'),
                  children: /*#__PURE__*/jsxs(CDSEmptyState, {
                    children: [/*#__PURE__*/jsx(CDSEmptyState.Illustration, {
                      variant: "info"
                    }), /*#__PURE__*/jsx(CDSEmptyState.Message, {
                      children: emptyStateMessage
                    })]
                  })
                })]
              })
            })
          })]
        }), /*#__PURE__*/jsx("input", {
          type: "hidden",
          name: name,
          value: getSelectedValues(value, selectedOptions, multiple)
        }), error && renderError()]
      })
    })
  });
});
CDSSelect.displayName = 'CDSSelect';
CDSSelect.defaultProps = {
  value: undefined,
  name: undefined,
  label: undefined,
  size: 'md',
  options: [],
  clearable: false,
  withAdd: false,
  withTags: false,
  withCheck: false,
  withSearch: false,
  withTypeahead: false,
  placeholder: undefined,
  multiple: false,
  onToggle: undefined,
  onClear: undefined,
  onSearch: undefined,
  onBlur: undefined,
  onAdd: undefined,
  onRemove: undefined,
  errorMessage: 'You must select an option.',
  emptyStateMessage: 'No matches found',
  infoMessage: undefined,
  isOpen: false,
  withTruncatedTags: false,
  optional: undefined
};

export { CDSSelect, CDSSelect as default, getSelectedLabels, getTooltipLabel };
