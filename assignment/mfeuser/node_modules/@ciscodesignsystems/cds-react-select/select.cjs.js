'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jsxRuntime = require('react/jsx-runtime');
var react = require('react');
var react$1 = require('@floating-ui/react');
var phosphorReact = require('phosphor-react');
var cdsComponentUtilities = require('@ciscodesignsystems/cds-component-utilities');
var cdsReactEmptyState = require('@ciscodesignsystems/cds-react-empty-state');
var cdsReactFlex = require('@ciscodesignsystems/cds-react-flex');
var cdsReactLabel = require('@ciscodesignsystems/cds-react-label');
var cdsReactTooltip = require('@ciscodesignsystems/cds-react-tooltip');
var selectItem = require('./components/item/select-item.cjs.js');
var addItem = require('./components/add-item/add-item.cjs.js');
var useFloatingSelect = require('./use-floating-select.cjs.js');
var useSelectItems = require('./use-select-items.cjs.js');
var useTypeahead = require('./use-typeahead.cjs.js');
var supportFunctions = require('./util/support-functions.cjs.js');
var truncatedText = require('./util/truncated-text.cjs.js');
var select_module = require('./select.module.cjs.js');

const focus = {
  triggerManualFocus: false
};
const getTooltipLabel = (selectedOptions, multiple) => {
  return selectedOptions === null || selectedOptions === void 0 ? void 0 : selectedOptions.map(option => {
    return option.label;
  }).join(multiple ? ', ' : '');
};
const getSelectedLabels = (selectedOptions, multiple) => {
  return selectedOptions === null || selectedOptions === void 0 ? void 0 : selectedOptions.map(option => {
    return option.label;
  }).join(multiple ? ',' : '');
};
const CDSSelect = /*#__PURE__*/react.forwardRef((props, ref) => {
  var _a;
  const {
    id,
    icon,
    label,
    options: optionsProp,
    multiple,
    clearable,
    disabled,
    name,
    placeholder,
    withTags,
    withAdd,
    withSearch,
    withCheck,
    size,
    value,
    onToggle,
    onChange,
    onSearch,
    onClear,
    onBlur,
    onAdd,
    onRemove,
    error,
    errorMessage,
    emptyStateMessage,
    required,
    optional,
    withTypeahead,
    infoMessage,
    isOpen: propOpen = false,
    className,
    withTruncatedTags,
    ...rest
  } = props;
  const [isFocused, setIsFocused] = react.useState(false);
  const [isMenuOpen, setIsMenuOpen] = react.useState(propOpen);
  const [inputValue, setInputValue] = react.useState('');
  const inputRef = /*#__PURE__*/react.createRef();
  const toggleRef = /*#__PURE__*/react.createRef();
  const options = react.useMemo(() => optionsProp.map(option => ({
    ...option
  })), [optionsProp]);
  react.useEffect(() => {
    setIsMenuOpen(propOpen);
  }, [propOpen]);
  const handleToggle = e => {
    setIsMenuOpen(e);
    onToggle === null || onToggle === void 0 ? void 0 : onToggle(e);
  };
  const {
    removeOption,
    clearSearchValue,
    setSearchValue,
    clearSelected,
    updateSelect,
    selectOption,
    selectedOptions = [],
    filteredOptions,
    groupedOptions,
    hasOptionsGroups,
    addOption,
    deselectOption,
    getSelectedOptions
  } = useSelectItems.useSelectItems({
    options: options,
    selectedOptions: [],
    filteredOptions: options,
    multiple
  });
  const previousOptions = react.useRef([]);
  react.useEffect(() => {
    if (JSON.stringify(previousOptions.current) !== JSON.stringify(options)) {
      updateSelect(options);
      previousOptions.current = options;
    }
  }, [updateSelect, options]);
  const suggestions = useTypeahead.useTypeahead({
    inputValue,
    items: options,
    enabled: withTypeahead
  });
  const {
    x,
    y,
    strategy,
    refs,
    context,
    getFloatingProps,
    getItemProps,
    listRef,
    selectedIndex,
    activeIndex
  } = useFloatingSelect.useFloatingSelect(isMenuOpen, handleToggle);
  const handleMultiSelect = item => {
    const selectedItems = getSelectedOptions();
    if (item.selected) {
      deselectOption(item);
      return selectedItems.filter(selectedItem => selectedItem.value !== item.value);
    }
    selectOption(item);
    handleToggle(true);
    return selectedItems.concat({
      ...item,
      selected: true
    });
  };
  const handleSelect = item => {
    if (multiple) {
      const selectedItems = handleMultiSelect(item);
      onChange === null || onChange === void 0 ? void 0 : onChange(selectedItems);
    } else {
      clearSelected();
      selectOption(item);
      handleToggle(false);
      onChange === null || onChange === void 0 ? void 0 : onChange({
        ...item,
        selected: true
      });
    }
    if ((withSearch || withTypeahead) && !multiple) {
      clearSearchValue();
      setInputValue('');
    }
  };
  const parentRef = react.useRef(null);
  const handleBlurWhenFocusedOnMainDiv = event => {
    if (!isMenuOpen) {
      onBlur === null || onBlur === void 0 ? void 0 : onBlur(event);
    }
    setIsFocused(isMenuOpen);
    if (!inputValue) {
      setInputValue('');
      clearSearchValue();
    }
  };
  const handleFocus = () => {
    setIsFocused(true);
  };
  const handleOpen = (open = true) => {
    setIsMenuOpen(open);
    handleToggle(open);
    onToggle === null || onToggle === void 0 ? void 0 : onToggle(open);
  };
  const handleRemove = option => {
    option.selected = !option.selected;
    onRemove === null || onRemove === void 0 ? void 0 : onRemove(option);
    removeOption(option);
    handleOpen(false);
    onChange === null || onChange === void 0 ? void 0 : onChange(getSelectedOptions());
  };
  const handleInputContainerClick = () => {
    var _a;
    if (withSearch) {
      (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.focus();
    }
    handleToggle(!isMenuOpen);
  };
  const handleChange = event => {
    const value = event.target.value;
    setInputValue(value);
    handleToggle(Boolean(value));
    onSearch === null || onSearch === void 0 ? void 0 : onSearch(value);
    setSearchValue(value);
  };
  const handleAddClick = () => {
    const opt = {
      selected: true,
      label: inputValue,
      value: inputValue
    };
    supportFunctions.handleClear(setInputValue, clearSearchValue, clearSelected, inputRef, onClear, multiple);
    handleToggle(Boolean(multiple));
    addOption(opt);
    onAdd === null || onAdd === void 0 ? void 0 : onAdd(opt);
  };
  const handleKeyDown = e => {
    if ((withSearch || withTypeahead) && inputValue === '' && e.key === 'Backspace') {
      return supportFunctions.handleClear(setInputValue, clearSearchValue, clearSelected, inputRef, onClear);
    }
    if (e.key === 'Enter') {
      return;
    }
  };
  const getOptions = () => {
    if (inputValue && withTypeahead && suggestions) {
      return suggestions;
    } else if (hasOptionsGroups && (!withSearch || !inputValue)) {
      return groupedOptions;
    } else if (withSearch && inputValue && filteredOptions) {
      return filteredOptions;
    }
    return options;
  };
  const showSearchInput = withTypeahead || withSearch;
  const hasSelectedOptions = () => {
    return getSelectedOptions().length > 0;
  };
  const cdsSelectClassname = 'cds-select';
  const cdsSelectClasses = cdsComponentUtilities.cx(select_module["default"], cdsSelectClassname, `${cdsSelectClassname}--${size}`, {
    [`${cdsSelectClassname}--show-search`]: showSearchInput,
    [`${cdsSelectClassname}--show-add`]: withAdd,
    [`${cdsSelectClassname}--show-tags`]: withTags,
    [`${cdsSelectClassname}--show-typeahead`]: withTypeahead,
    [`${cdsSelectClassname}--disabled`]: disabled,
    [`${cdsSelectClassname}--empty`]: !hasSelectedOptions(),
    [`cds-sentiment--negative`]: error
  }, className);
  const cdsSelectControlClasses = cdsComponentUtilities.cx(select_module["default"], `${cdsSelectClassname}__control`, {
    [`${cdsSelectClassname}__control--focus`]: isFocused || isMenuOpen,
    [`${cdsSelectClassname}__control--show-search`]: isFocused && showSearchInput,
    [`${cdsSelectClassname}__control--open`]: isMenuOpen
  });
  const cdsSelectValueContainerClasses = cdsComponentUtilities.cx(select_module["default"], `${cdsSelectClassname}__value-container`, {
    [`${cdsSelectClassname}__value-container--multiple--with-tag`]: multiple && withTags
  });
  const cdsSelectClassNames = (name, modifiers) => {
    return cdsComponentUtilities.cx(select_module["default"], `${cdsSelectClassname}__${name}`, modifiers);
  };
  /**
   * Render individual option element.
   * @param {number} index The current index
   * @param {CDSOption} option The current option
   */
  function renderOptionElement(option, index) {
    const {
      onFocus,
      onMouseMove,
      onPointerLeave
    } = getItemProps();
    return jsxRuntime.jsx(selectItem.CDSSelectItem, {
      ref: node => {
        listRef.current[index] = node;
      },
      withCheck: withCheck,
      size: size,
      multiple: multiple,
      option: option,
      onSelect: handleSelect,
      tabIndex: index === activeIndex ? 0 : -1,
      "aria-selected": option.selected || index === selectedIndex && index === activeIndex,
      onFocus: () => onFocus,
      onMouseMove: () => onMouseMove,
      onPointerLeave: () => onPointerLeave
    }, `${index}-${option.label}`);
  }
  react.useEffect(() => {
    supportFunctions.handleBlurWhenFocusedOnOptionsDiv({
      isOpen: isMenuOpen,
      multiple,
      showSearchInput,
      focus,
      inputRef,
      parentRef
    });
  }, [inputRef, isMenuOpen, multiple, showSearchInput]);
  const renderError = () => jsxRuntime.jsxs("div", {
    className: cdsSelectClassNames('error'),
    "data-testid": 'cds-select-error',
    children: [jsxRuntime.jsx("span", {
      className: cdsSelectClassNames('error-icon'),
      children: jsxRuntime.jsx(phosphorReact.WarningOctagon, {
        size: 20,
        weight: "fill"
      })
    }), jsxRuntime.jsx("span", {
      className: cdsSelectClassNames('error-message'),
      children: errorMessage
    })]
  });
  const renderLabel = (name, label, required, infoMessage, optional) => {
    return jsxRuntime.jsx(cdsReactLabel.CDSLabel, {
      size: size,
      htmlFor: name,
      className: cdsComponentUtilities.cx(select_module["default"], 'cds-label'),
      role: "none",
      title: label,
      required: required,
      optional: optional,
      infoMessage: infoMessage,
      onClick: () => {
        var _a;
        (_a = toggleRef.current) === null || _a === void 0 ? void 0 : _a.focus();
      },
      children: label
    });
  };
  const placeholderMultipleSelectWithoutTags = placeholder && !withTags && !showSearchInput && label;
  const root = react.useRef(null);
  const mergedRefs = react$1.useMergeRefs([ref, root]);
  const getPlaceholderDiv = () => {
    if ((!multiple || withTags) && hasSelectedOptions()) return undefined;else if (placeholderMultipleSelectWithoutTags && !icon) return jsxRuntime.jsx("div", {
      className: cdsSelectClassNames('placeholder'),
      children: supportFunctions.getPlaceholder({
        withSearch,
        withAdd,
        hasSelectedOptions,
        multiple,
        label,
        placeholder,
        withTags
      })
    });else if (placeholder && !showSearchInput) {
      return jsxRuntime.jsxs("div", {
        className: cdsSelectClassNames('placeholder'),
        children: [icon && jsxRuntime.jsx("span", {
          className: cdsSelectClassNames('value-icon'),
          children: icon
        }), supportFunctions.getPlaceholder({
          withSearch,
          withAdd,
          hasSelectedOptions,
          multiple,
          label,
          placeholder,
          withTags
        })]
      });
    }
    return undefined;
  };
  const isTagTruncationTooltipDisabled = optionLabel => {
    if (withTruncatedTags) {
      return !!optionLabel && optionLabel.length <= (typeof withTruncatedTags === 'number' ? withTruncatedTags : truncatedText.MIN_TRUNCATION_DEFAULT);
    }
    return true;
  };
  return jsxRuntime.jsx("div", {
    className: cdsSelectClasses,
    ref: mergedRefs,
    ...rest,
    children: jsxRuntime.jsx(cdsReactFlex.CDSFlex, {
      direction: "vertical",
      children: jsxRuntime.jsxs(jsxRuntime.Fragment, {
        children: [label && renderLabel(name, label, required, infoMessage, optional), jsxRuntime.jsxs("div", {
          className: cdsSelectControlClasses,
          onKeyDown: handleKeyDown,
          role: 'presentation',
          ...getFloatingProps(),
          ref: react$1.useMergeRefs([refs.setReference, parentRef]),
          onBlur: handleBlurWhenFocusedOnMainDiv,
          ...supportFunctions.tabIndex(!!withSearch),
          "data-testid": 'cds-select-control',
          children: [jsxRuntime.jsxs("div", {
            className: cdsSelectValueContainerClasses,
            role: "none",
            children: [hasSelectedOptions() && !multiple && !inputValue && jsxRuntime.jsxs("div", {
              className: cdsSelectClassNames('value'),
              "data-testid": 'cds-select-value',
              onKeyDown: event => {
                if (event.key === 'Enter') {
                  event.preventDefault();
                  handleToggle(!isMenuOpen);
                }
              },
              onClick: () => handleToggle(!isMenuOpen),
              role: "none",
              children: [((_a = selectedOptions[0]) === null || _a === void 0 ? void 0 : _a.icon) && jsxRuntime.jsx("span", {
                className: cdsSelectClassNames('value-icon'),
                children: selectedOptions[0].icon
              }), jsxRuntime.jsx("span", {
                className: cdsSelectClassNames('value-label'),
                children: !inputValue && getSelectedLabels(selectedOptions, multiple)
              })]
            }), multiple && hasSelectedOptions() && (withTags ? jsxRuntime.jsx("ul", {
              className: cdsSelectClassNames('tags'),
              "data-testid": 'cds-select-tags',
              children: [...getSelectedOptions()].map(option => jsxRuntime.jsx(cdsReactTooltip.CDSTooltip, {
                autoPlacement: true,
                disabled: isTagTruncationTooltipDisabled(option.label),
                title: withTruncatedTags && option.label ? option.label : '',
                children: jsxRuntime.jsxs("li", {
                  className: cdsSelectClassNames('tag', !isTagTruncationTooltipDisabled(option.label) ? 'cds-select--truncated' : undefined),
                  children: [(option === null || option === void 0 ? void 0 : option.icon) && jsxRuntime.jsx("span", {
                    className: cdsSelectClassNames('value-icon'),
                    children: option.icon
                  }), jsxRuntime.jsx("span", {
                    className: cdsSelectClassNames('tag-label'),
                    children: withTruncatedTags ? truncatedText.truncateText(option.label, withTruncatedTags) : option.label
                  }), jsxRuntime.jsx("span", {
                    tabIndex: 0,
                    role: "button",
                    className: cdsSelectClassNames('tag-action'),
                    title: `Remove ${option.label}`,
                    onKeyDown: event => {
                      if (event.key === 'Enter') {
                        event.preventDefault();
                        handleRemove(option);
                      }
                    },
                    onClick: event => {
                      event.preventDefault();
                      handleRemove(option);
                    },
                    children: jsxRuntime.jsx(phosphorReact.X, {
                      size: 14,
                      weight: "bold"
                    })
                  })]
                }, `tag-${option.label}`)
              }, `tag-${option.label}`))
            }) : jsxRuntime.jsx(cdsReactTooltip.CDSTooltip, {
              title: getTooltipLabel(selectedOptions, multiple),
              children: jsxRuntime.jsx("span", {
                className: cdsSelectClassNames('tag'),
                children: getSelectedOptions().length
              })
            }))]
          }), jsxRuntime.jsxs("div", {
            className: cdsSelectClassNames('input-container'),
            "data-testid": 'cds-select-input-container',
            role: "none",
            onClick: handleInputContainerClick,
            onKeyDown: event => {
              if (event.key === 'Enter') {
                event.preventDefault();
                handleInputContainerClick();
              }
            },
            children: [getPlaceholderDiv(), showSearchInput && jsxRuntime.jsx("input", {
              "data-testid": 'cds-select-input',
              className: cdsSelectClassNames('input'),
              type: "text",
              ref: inputRef,
              tabIndex: -1,
              value: inputValue,
              placeholder: String(supportFunctions.getPlaceholder({
                withSearch,
                withAdd,
                hasSelectedOptions,
                multiple,
                label,
                placeholder,
                withTags
              })),
              onKeyDown: handleKeyDown,
              onFocus: handleFocus,
              onChange: handleChange
            })]
          }), jsxRuntime.jsxs("div", {
            className: cdsSelectClassNames('indicator-container'),
            children: [clearable && hasSelectedOptions() && jsxRuntime.jsx("button", {
              "data-testid": 'cds-select-indicator-clear',
              className: cdsSelectClassNames('indicator-clear'),
              type: 'button',
              "aria-label": 'Clear',
              onClick: () => supportFunctions.handleClear(setInputValue, clearSearchValue, clearSelected, inputRef, onClear),
              children: jsxRuntime.jsx(phosphorReact.XCircle, {
                size: 18
              })
            }), jsxRuntime.jsx("button", {
              "data-testid": 'cds-select-indicator-dropdown',
              className: cdsSelectClassNames('indicator-dropdown'),
              type: 'button',
              "aria-label": 'Open',
              "aria-expanded": isMenuOpen,
              ref: toggleRef,
              onClick: () => {
                handleToggle(!isMenuOpen);
              },
              children: jsxRuntime.jsx(phosphorReact.CaretDown, {
                size: 18,
                weight: "bold"
              })
            })]
          }), jsxRuntime.jsx(react$1.FloatingPortal, {
            id: id,
            root: root.current,
            "data-testid": 'cds-select-portal',
            children: isMenuOpen && jsxRuntime.jsx(react$1.FloatingFocusManager, {
              context: context,
              modal: false,
              visuallyHiddenDismiss: true,
              initialFocus: withSearch || withTypeahead ? inputRef : -1,
              children: jsxRuntime.jsxs("div", {
                "data-testid": 'cds-select-menu',
                tabIndex: 0,
                onKeyDown: () => ({}),
                className: cdsSelectClassNames('menu', [`cds-select__menu--${size}`]),
                ref: refs.setFloating,
                role: "listbox",
                "aria-multiselectable": Boolean(multiple),
                onClick: () => focus.triggerManualFocus = true,
                style: {
                  position: strategy,
                  top: y !== null && y !== void 0 ? y : 0,
                  left: x !== null && x !== void 0 ? x : 0,
                  overflowY: 'auto',
                  boxSizing: 'border-box',
                  outline: 0
                },
                children: [options && !hasOptionsGroups && getOptions().map(renderOptionElement), hasOptionsGroups && getOptions().map((group, index) => {
                  return jsxRuntime.jsxs(react.Fragment, {
                    children: [jsxRuntime.jsx("div", {
                      className: cdsComponentUtilities.cx(select_module["default"], 'cds-select__item cds-select__item--group'),
                      children: jsxRuntime.jsx("span", {
                        children: group.label
                      })
                    }), group.options.map(renderOptionElement)]
                  }, `group-${group.label}`);
                }), withAdd && inputValue && !hasOptionsGroups && jsxRuntime.jsx(addItem.CDSSelectAddItem, {
                  inputValue: inputValue,
                  handleAddClick: handleAddClick,
                  size: size
                }), !withAdd && getOptions().length === 0 && jsxRuntime.jsx("div", {
                  className: cdsSelectClassNames('empty-state'),
                  children: jsxRuntime.jsxs(cdsReactEmptyState.CDSEmptyState, {
                    children: [jsxRuntime.jsx(cdsReactEmptyState.CDSEmptyState.Illustration, {
                      variant: "info"
                    }), jsxRuntime.jsx(cdsReactEmptyState.CDSEmptyState.Message, {
                      children: emptyStateMessage
                    })]
                  })
                })]
              })
            })
          })]
        }), jsxRuntime.jsx("input", {
          type: "hidden",
          name: name,
          value: supportFunctions.getSelectedValues(value, selectedOptions, multiple)
        }), error && renderError()]
      })
    })
  });
});
CDSSelect.displayName = 'CDSSelect';
CDSSelect.defaultProps = {
  value: undefined,
  name: undefined,
  label: undefined,
  size: 'md',
  options: [],
  clearable: false,
  withAdd: false,
  withTags: false,
  withCheck: false,
  withSearch: false,
  withTypeahead: false,
  placeholder: undefined,
  multiple: false,
  onToggle: undefined,
  onClear: undefined,
  onSearch: undefined,
  onBlur: undefined,
  onAdd: undefined,
  onRemove: undefined,
  errorMessage: 'You must select an option.',
  emptyStateMessage: 'No matches found',
  infoMessage: undefined,
  isOpen: false,
  withTruncatedTags: false,
  optional: undefined
};

exports.CDSSelect = CDSSelect;
exports["default"] = CDSSelect;
exports.getSelectedLabels = getSelectedLabels;
exports.getTooltipLabel = getTooltipLabel;
