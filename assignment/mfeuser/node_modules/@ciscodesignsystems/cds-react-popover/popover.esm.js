import { forwardRef, useRef, useState, cloneElement } from 'react';
import { useFloating, autoUpdate, offset, flip, arrow, useInteractions, useHover, safePolygon, useFocus, useDismiss, useRole, useMergeRefs, FloatingPortal, FloatingArrow } from '@floating-ui/react';
import { cx } from '@ciscodesignsystems/cds-component-utilities';
import { CDSPopoverDivider } from './components/divider/index.esm.js';
import styles from './popover.module.esm.js';
import { jsxs, Fragment, jsx } from 'react/jsx-runtime';

const ARROW_HEIGHT = 8;
const ARROW_WIDTH = 16;
const OFFSET_GAP = 2;
const CDSPopover = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    children,
    className,
    disabled,
    offset: offsetGap,
    open: controlledOpen,
    placement,
    setOpen: controlledSetOpen,
    showArrow,
    size,
    title,
    variant,
    autoPlacement,
    root,
    preserveTabOrder,
    updateOnAnimationFrame,
    ...rest
  } = props;
  const classNames = cx(styles, `cds-popover`, `cds-popover--${size}`, `cds-popover--${variant}`, className);
  const arrowRef = useRef(null);
  const [uncontrolledOpen, uncontrolledSetOpen] = useState(false);
  const open = controlledOpen ?? uncontrolledOpen;
  const setOpen = controlledSetOpen ?? uncontrolledSetOpen;
  const {
    context,
    refs,
    strategy,
    x,
    y
  } = useFloating({
    placement,
    open,
    onOpenChange: setOpen,
    whileElementsMounted(referenceEl, floatingEl, update) {
      return autoUpdate(referenceEl, floatingEl, update, {
        animationFrame: updateOnAnimationFrame
      });
    },
    middleware: [offset(offsetGap), autoPlacement && flip({
      fallbackPlacements: ['top', 'right', 'bottom', 'left'],
      padding: 24
    }), arrow({
      element: arrowRef
    })]
  });
  const enabled = !disabled && !controlledSetOpen;
  const {
    getFloatingProps,
    getReferenceProps
  } = useInteractions([useHover(context, {
    handleClose: safePolygon(),
    enabled
  }), useFocus(context, {
    enabled
  }), useDismiss(context), useRole(context, {
    role: 'tooltip'
  })]);
  const floatingRef = useMergeRefs([refs.setFloating]);
  return /*#__PURE__*/jsxs(Fragment, {
    children: [/*#__PURE__*/cloneElement(children, {
      ref: useMergeRefs([refs.setReference, children.props.ref, ref]),
      ...getReferenceProps()
    }), /*#__PURE__*/jsx(FloatingPortal, {
      preserveTabOrder: preserveTabOrder,
      ...(root ? {
        root
      } : {}),
      children: open && !disabled && /*#__PURE__*/jsxs("div", {
        className: classNames,
        ref: floatingRef,
        style: {
          position: strategy,
          top: y,
          left: x
        },
        ...rest,
        ...getFloatingProps({}),
        children: [showArrow && /*#__PURE__*/jsx(FloatingArrow, {
          className: cx(styles, `cds-popover--${variant}__arrow`),
          context: context,
          height: ARROW_HEIGHT,
          ref: arrowRef,
          width: ARROW_WIDTH
        }), title]
      })
    })]
  });
});
CDSPopover.displayName = 'CDSPopover';
CDSPopover.defaultProps = {
  disabled: false,
  offset: ARROW_HEIGHT + OFFSET_GAP,
  open: undefined,
  placement: 'top',
  setOpen: undefined,
  showArrow: true,
  size: 'md',
  variant: 'default',
  autoPlacement: true,
  preserveTabOrder: true,
  root: null,
  updateOnAnimationFrame: false
};
const CDSPopoverNamespace = Object.assign(CDSPopover, {
  Divider: CDSPopoverDivider
});
CDSPopoverNamespace.displayName = 'CDSPopover';

export { CDSPopoverNamespace as CDSPopover, CDSPopover as default };
