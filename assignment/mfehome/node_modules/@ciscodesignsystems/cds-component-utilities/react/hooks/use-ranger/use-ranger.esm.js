import { useState, useCallback, useMemo, useRef } from 'react';

const getBoundingClientRect = element => {
  const rect = element && element.current ? element.current.getBoundingClientRect() : {
    left: 0,
    width: 0
  };
  return {
    left: Math.ceil(rect.left),
    width: Math.ceil(rect.width)
  };
};
const sortNumList = arr => {
  return [...arr].sort((a, b) => {
    return Number(a) - Number(b);
  });
};
const useGetLatest = val => {
  const ref = useRef(val);
  ref.current = val;
  return useCallback(() => {
    return ref.current;
  }, []);
};
const linearInterpolator = {
  getPercentageForValue: (val, min, max) => {
    return Math.max(0, Math.min(100, (val - min) / (max - min) * 100));
  },
  getValueForClientX: (clientX, trackDims, min, max) => {
    const left = trackDims.left,
      width = trackDims.width;
    const percentageValue = (clientX - left) / width;
    const value = (max - min) * percentageValue;
    return value + min;
  }
};
function useRanger(props) {
  const {
    interpolator = linearInterpolator,
    tickSize = 10,
    values,
    min,
    max,
    ticks: controlledTicks,
    steps,
    onChange,
    onDrag,
    stepSize,
    draggableTrack = false
  } = props;
  const [activeHandleIndex, setActiveHandleIndex] = useState(null);
  const [tempValues, setTempValues] = useState();
  const getLatest = useGetLatest({
    activeHandleIndex: activeHandleIndex,
    onChange: onChange,
    onDrag: onDrag,
    values: values,
    tempValues: tempValues
  });
  let trackElRef;
  const getValueForClientX = useCallback(clientX => {
    const trackDims = getBoundingClientRect(trackElRef);
    return interpolator.getValueForClientX(clientX, trackDims, min, max);
  }, [interpolator, max, min, trackElRef]);
  const getNextStep = useCallback((val, direction) => {
    if (steps) {
      const currIndex = steps.indexOf(val);
      const nextIndex = currIndex + direction;
      if (nextIndex >= 0 && nextIndex < steps.length) {
        return steps[nextIndex];
      } else {
        return val;
      }
    } else {
      const nextVal = val + stepSize * direction;
      if (nextVal >= min && nextVal <= max) {
        return nextVal;
      } else {
        return val;
      }
    }
  }, [max, min, stepSize, steps]);
  const roundToStep = useCallback(val => {
    let left = min;
    let right = max;
    if (steps) {
      steps.forEach(step => {
        if (step <= val && step > left) {
          left = step;
        }
        if (step >= val && step < right) {
          right = step;
        }
      });
    } else {
      while (left < val && left + stepSize < val) {
        left += stepSize;
      }
      right = Math.min(left + stepSize, max);
    }
    if (val - left < right - val) {
      return left;
    }
    return right;
  }, [max, min, stepSize, steps]);
  const handleDrag = useCallback(e => {
    const {
      activeHandleIndex,
      onDrag
    } = getLatest();
    const clientX = e.type === 'touchmove' ? e.changedTouches[0].clientX : e.clientX;
    const newValue = getValueForClientX(clientX);
    const newRoundedValue = roundToStep(newValue);
    const newValues = activeHandleIndex !== null ? [...values.slice(0, activeHandleIndex), newRoundedValue, ...values.slice(activeHandleIndex + 1)] : [];
    if (onDrag) {
      onDrag(newValues);
    } else {
      setTempValues(newValues);
    }
  }, [getLatest, getValueForClientX, roundToStep, setTempValues, values]);
  const handleKeyDown = useCallback((e, i) => {
    const {
      values,
      onChange = () => ({})
    } = getLatest();
    if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
      setActiveHandleIndex(i);
      const direction = e.key === 'ArrowLeft' ? -1 : 1;
      const newValue = getNextStep(values[i], direction);
      const newValues = [...values.slice(0, i), newValue, ...values.slice(i + 1)];
      const sortedValues = sortNumList(newValues);
      onChange(sortedValues);
    }
  }, [getLatest, getNextStep, setActiveHandleIndex]);
  const handlePress = useCallback((e, i) => {
    setActiveHandleIndex(i);
    const handleRelease = e => {
      const {
        tempValues,
        values,
        onChange = () => ({}),
        onDrag = () => ({})
      } = getLatest();
      document.removeEventListener('mousemove', handleDrag);
      document.removeEventListener('touchmove', handleDrag);
      document.removeEventListener('mouseup', handleRelease);
      document.removeEventListener('touchend', handleRelease);
      const sortedValues = sortNumList(tempValues || values);
      onChange(sortedValues);
      onDrag(sortedValues);
      setActiveHandleIndex(null);
    };
    document.addEventListener('mousemove', handleDrag);
    document.addEventListener('touchmove', handleDrag);
    document.addEventListener('mouseup', handleRelease);
    document.addEventListener('touchend', handleRelease);
  }, [getLatest, handleDrag]);
  const handleSegmentDrag = useCallback((e, initialX) => {
    const {
      onDrag = () => ({})
    } = getLatest();
    const clientX = e.type === 'touchmove' ? e.changedTouches[0].clientX : e.clientX;
    const initialValue = getValueForClientX(initialX);
    const newValue = getValueForClientX(clientX);
    const diff = newValue - initialValue;
    if (diff > 0) {
      const last = values[values.length - 1];
      const newRoundedLastValue = roundToStep(last + diff);
      onDrag(values.map(val => roundToStep(val + (newRoundedLastValue - last))));
    } else if (diff < 0) {
      const first = values[0];
      const newRoundedFirstValue = roundToStep(first + diff);
      onDrag(values.map(val => roundToStep(val + (newRoundedFirstValue - first))));
    }
  }, [getLatest, getValueForClientX, roundToStep, values]);
  const handleSegmentPress = useCallback(e => {
    const clientX = e.type === 'touchmove' ? e.changedTouches[0].clientX : e.clientX;
    const onSegmentDrag = e => handleSegmentDrag(e, clientX);
    const handleRelease = e => {
      document.removeEventListener('mousemove', onSegmentDrag);
      document.removeEventListener('touchmove', onSegmentDrag);
      document.removeEventListener('mouseup', handleRelease);
      document.removeEventListener('touchend', handleRelease);
    };
    document.addEventListener('mousemove', onSegmentDrag);
    document.addEventListener('touchmove', onSegmentDrag);
    document.addEventListener('mouseup', handleRelease);
    document.addEventListener('touchend', handleRelease);
  }, [handleSegmentDrag]);
  const getPercentageForValue = useCallback(val => {
    return interpolator.getPercentageForValue(val, min, max);
  }, [interpolator, max, min]); // Build the ticks

  const ticks = useMemo(() => {
    let ticks = controlledTicks || steps;
    if (!ticks) {
      ticks = [min];
      while (ticks[ticks.length - 1] < max - tickSize) {
        ticks.push(ticks[ticks.length - 1] + tickSize);
      }
      ticks.push(max);
    }
    return ticks.map((value, i) => {
      return {
        value: value,
        getTickProps: ({
          key = i,
          style,
          ...rest
        }) => {
          return {
            key: key,
            style: {
              position: 'absolute',
              width: 0,
              left: `${getPercentageForValue(value)}%`,
              transform: 'translateX(-50%)',
              ...style
            },
            ...rest
          };
        }
      };
    });
  }, [controlledTicks, getPercentageForValue, max, min, steps, tickSize]);
  const segments = useMemo(() => {
    const sortedValues = sortNumList(tempValues || values);
    return [...sortedValues, max].map((value, i) => {
      return {
        value: value,
        getSegmentProps: ({
          key = i,
          style,
          onMouseDown: _onMouseDown = () => ({}),
          onTouchStart: _onTouchStart = () => ({}),
          ...rest
        }) => {
          const left = getPercentageForValue(sortedValues[i - 1] ? sortedValues[i - 1] : min);
          const width = getPercentageForValue(value) - left;
          return {
            key: key,
            style: {
              position: 'absolute',
              left: `${left}%`,
              width: `${width}%`,
              ...style
            },
            onMouseDown: e => {
              e.preventDefault();
              if (draggableTrack && i === 1) {
                handleSegmentPress(e);
                _onMouseDown(e);
              }
            },
            onTouchStart: e => {
              e.preventDefault();
              if (draggableTrack && i === 1) {
                handleSegmentPress(e);
                _onTouchStart(e);
              }
            },
            ...rest
          };
        }
      };
    });
  }, [draggableTrack, getPercentageForValue, handleSegmentPress, max, min, tempValues, values]);
  const handles = useMemo(() => {
    return (tempValues || values).map((value, i) => {
      return {
        value: value,
        active: i === activeHandleIndex,
        getHandleProps: props => {
          const {
            key = i,
            style,
            onKeyDown: _onKeyDown,
            onMouseDown: _onMouseDown,
            onTouchStart: _onTouchStart,
            ...rest
          } = props;
          return {
            key: key,
            onKeyDown: e => {
              e.preventDefault();
              handleKeyDown(e, i);
              _onKeyDown && _onKeyDown(e);
            },
            onMouseDown: e => {
              e.preventDefault();
              handlePress(e, i);
              _onMouseDown && _onMouseDown(e);
            },
            onTouchStart: e => {
              e.preventDefault();
              handlePress(e, i);
              _onTouchStart && _onTouchStart(e);
            },
            role: 'slider',
            'aria-valuemin': min,
            'aria-valuemax': max,
            'aria-valuenow': value,
            style: {
              position: 'absolute',
              top: '50%',
              left: `${getPercentageForValue(value)}%`,
              transform: 'translate(-50%, -50%)',
              zIndex: i === activeHandleIndex ? '1' : '0',
              ...style
            },
            ...rest
          };
        }
      };
    });
  }, [activeHandleIndex, getPercentageForValue, handleKeyDown, handlePress, min, max, tempValues, values]);
  const getTrackProps = props => {
    const {
      style,
      trackRef,
      ...rest
    } = props;
    trackElRef = trackRef;
    return {
      style: {
        position: 'relative',
        userSelect: 'none',
        ...style
      },
      ...rest
    };
  };
  return {
    activeHandleIndex: activeHandleIndex,
    getTrackProps: getTrackProps,
    tickMarks: ticks,
    segments: segments,
    handles: handles
  };
}

export { useRanger };
