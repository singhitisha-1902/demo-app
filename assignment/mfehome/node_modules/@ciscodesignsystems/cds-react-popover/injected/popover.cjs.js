'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jsxRuntime = require('react/jsx-runtime');
var react = require('react');
var react$1 = require('@floating-ui/react');
var cdsComponentUtilities = require('@ciscodesignsystems/cds-component-utilities');
var index = require('./components/divider/index.cjs.js');
var popover_module = require('./popover.module.cjs.js');

const ARROW_HEIGHT = 8;
const ARROW_WIDTH = 16;
const OFFSET_GAP = 2;
const CDSPopover = /*#__PURE__*/react.forwardRef((props, ref) => {
  const {
    children,
    className,
    disabled,
    offset: offsetGap,
    open: controlledOpen,
    placement,
    setOpen: controlledSetOpen,
    showArrow,
    size,
    title,
    variant,
    autoPlacement,
    root,
    preserveTabOrder,
    updateOnAnimationFrame,
    ...rest
  } = props;
  const classNames = cdsComponentUtilities.cx(popover_module["default"], `cds-popover`, `cds-popover--${size}`, `cds-popover--${variant}`, className);
  const arrowRef = react.useRef(null);
  const [uncontrolledOpen, uncontrolledSetOpen] = react.useState(false);
  const open = controlledOpen !== null && controlledOpen !== void 0 ? controlledOpen : uncontrolledOpen;
  const setOpen = controlledSetOpen !== null && controlledSetOpen !== void 0 ? controlledSetOpen : uncontrolledSetOpen;
  const {
    context,
    refs,
    strategy,
    x,
    y
  } = react$1.useFloating({
    placement,
    open,
    onOpenChange: setOpen,
    whileElementsMounted(referenceEl, floatingEl, update) {
      return react$1.autoUpdate(referenceEl, floatingEl, update, {
        animationFrame: updateOnAnimationFrame
      });
    },
    middleware: [react$1.offset(offsetGap), autoPlacement && react$1.flip({
      fallbackPlacements: ['top', 'right', 'bottom', 'left'],
      padding: 24
    }), react$1.arrow({
      element: arrowRef
    })]
  });
  const enabled = !disabled && !controlledSetOpen;
  const {
    getFloatingProps,
    getReferenceProps
  } = react$1.useInteractions([react$1.useHover(context, {
    handleClose: react$1.safePolygon(),
    enabled
  }), react$1.useFocus(context, {
    enabled
  }), react$1.useDismiss(context), react$1.useRole(context, {
    role: 'tooltip'
  })]);
  const floatingRef = react$1.useMergeRefs([refs.setFloating]);
  return jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [/*#__PURE__*/react.cloneElement(children, {
      ref: react$1.useMergeRefs([refs.setReference, children.props.ref, ref]),
      ...getReferenceProps()
    }), jsxRuntime.jsx(react$1.FloatingPortal, {
      preserveTabOrder: preserveTabOrder,
      ...(root ? {
        root
      } : {}),
      children: open && !disabled && jsxRuntime.jsxs("div", {
        className: classNames,
        ref: floatingRef,
        style: {
          position: strategy,
          top: y,
          left: x
        },
        ...rest,
        ...getFloatingProps({}),
        children: [showArrow && jsxRuntime.jsx(react$1.FloatingArrow, {
          className: cdsComponentUtilities.cx(popover_module["default"], `cds-popover--${variant}__arrow`),
          context: context,
          height: ARROW_HEIGHT,
          ref: arrowRef,
          width: ARROW_WIDTH
        }), title]
      })
    })]
  });
});
CDSPopover.displayName = 'CDSPopover';
CDSPopover.defaultProps = {
  disabled: false,
  offset: ARROW_HEIGHT + OFFSET_GAP,
  open: undefined,
  placement: 'top',
  setOpen: undefined,
  showArrow: true,
  size: 'md',
  variant: 'default',
  autoPlacement: true,
  preserveTabOrder: true,
  root: null,
  updateOnAnimationFrame: false
};
const CDSPopoverNamespace = Object.assign(CDSPopover, {
  Divider: index.CDSPopoverDivider
});
CDSPopoverNamespace.displayName = 'CDSPopover';

exports.CDSPopover = CDSPopoverNamespace;
exports["default"] = CDSPopover;
