'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jsxRuntime = require('react/jsx-runtime');
var react = require('react');
var cdsComponentTypes = require('@ciscodesignsystems/cds-component-types');
var cdsComponentUtilities = require('@ciscodesignsystems/cds-component-utilities');
var inputFrame = require('./components/input-frame/input-frame.cjs.js');
var index = require('./components/suffix/index.cjs.js');
var textInput_module = require('./text-input.module.cjs.js');

const CDSTextInput = /*#__PURE__*/react.forwardRef((props, ref) => {
  var _a;
  const {
    size,
    sentiment,
    bordered,
    disabled,
    invalid,
    prefix,
    suffix,
    className,
    style,
    label,
    optional,
    tooltip,
    fixedWidth,
    value: valueFromProps,
    onChange: onChangeFromProps,
    clearable,
    defaultValue,
    onClear,
    type = 'text',
    onClick,
    onBlur,
    showPasswordText,
    hidePasswordText,
    ...rest
  } = props;
  const [value, setValue] = react.useState((_a = defaultValue !== null && defaultValue !== void 0 ? defaultValue : valueFromProps) !== null && _a !== void 0 ? _a : '');
  const [showPassword, setShowPassword] = react.useState(false);
  const inputType = showPassword ? 'text' : 'password';
  const computedType = type !== 'password' ? type : inputType;
  const inputRef = react.useRef(null);
  const mergedRef = cdsComponentTypes.useMergeRefs([inputRef, ref]);
  const handleClick = event => {
    if (inputRef.current) {
      inputRef.current.focus();
    }
    if (onClick) {
      onClick(event);
    }
  };
  const handleBlur = event => {
    var _a, _b;
    if ((_b = (_a = event === null || event === void 0 ? void 0 : event.relatedTarget) === null || _a === void 0 ? void 0 : _a.classList) === null || _b === void 0 ? void 0 : _b.contains('cds-text-input__toggle-password')) {
      return;
    }
    if (inputRef.current) {
      inputRef.current.blur();
    }
    if (onBlur) {
      onBlur(event);
    }
  };
  const handleClear = () => {
    setValue('');
    onClear === null || onClear === void 0 ? void 0 : onClear();
  };
  const handleChange = event => {
    setValue(event.target.value);
    onChangeFromProps === null || onChangeFromProps === void 0 ? void 0 : onChangeFromProps(event);
  };
  return jsxRuntime.jsx(inputFrame.CDSInputFrame, {
    prefix: prefix,
    suffix: jsxRuntime.jsx(index["default"], {
      type: type,
      setShowPassword: setShowPassword,
      showPassword: showPassword,
      suffix: suffix,
      hasValue: !!value,
      onClear: clearable ? handleClear : undefined,
      disabled: disabled,
      showPasswordText: showPasswordText,
      hidePasswordText: hidePasswordText
    }),
    size: size,
    bordered: bordered,
    sentiment: invalid && 'negative' || sentiment,
    className: className,
    style: style,
    disabled: disabled,
    label: label,
    optional: optional,
    tooltip: tooltip,
    required: rest.required,
    fixedWidth: fixedWidth,
    id: rest.id,
    onClick: handleClick,
    onBlur: handleBlur,
    children: jsxRuntime.jsx("input", {
      className: cdsComponentUtilities.cx(textInput_module["default"], 'cds-text-input'),
      ref: mergedRef,
      disabled: disabled,
      onChange: handleChange,
      value: valueFromProps !== null && valueFromProps !== void 0 ? valueFromProps : value,
      type: computedType,
      ...rest
    })
  });
});
CDSTextInput.displayName = 'CDSTextInput';
CDSTextInput.defaultProps = {
  size: 'md',
  sentiment: 'control',
  bordered: true,
  invalid: false,
  prefix: undefined,
  suffix: undefined,
  tooltip: undefined,
  optional: undefined,
  label: undefined,
  fixedWidth: false,
  clearable: false,
  className: '',
  onClear: undefined,
  onClick: undefined,
  onBlur: undefined,
  onChange: undefined
};

exports.CDSTextInput = CDSTextInput;
exports["default"] = CDSTextInput;
