'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jsxRuntime = require('react/jsx-runtime');
var react = require('react');
var react$1 = require('@floating-ui/react');
var framerMotion = require('framer-motion');
var cdsComponentTypes = require('@ciscodesignsystems/cds-component-types');
var cdsComponentUtilities = require('@ciscodesignsystems/cds-component-utilities');
var navContext = require('../../context/nav-context.cjs.js');
var navMenuContext = require('../../context/nav-menu-context.cjs.js');
var index = require('../../types/index.cjs.js');
var navItemBase = require('./nav-item-base.cjs.js');
var navItemWithSubmenu_module = require('./nav-item-with-submenu.module.cjs.js');

const CDSNavItemWithSubMenu = /*#__PURE__*/react.forwardRef((props, ref) => {
  var _a;
  const {
    menu,
    icon,
    children,
    className,
    onMouseEnter,
    onMouseLeave,
    ...rest
  } = props;
  const id = react$1.useId();
  const subMenuId = `cds-nav-submenu-${react$1.useId()}`;
  const {
    reducerState,
    reducerDispatch,
    floatingMenuAnimationX,
    floatingMenuPositionRef,
    navItemRefs
  } = navContext.useNavContext();
  const isSubMenuOpen = menu && reducerState.id === id && reducerState.isOpen;
  const isSubMenuAnimating = menu && reducerState.id === id && reducerState.isAnimating;
  const subMenuToShow = reducerState.subMenuStack.at(-1);
  const getReducerActionFromFloatingEvent = react.useCallback(e => {
    if (e === undefined) {
      return null;
    } else if (e.type === 'keydown' && e.key === 'Escape') {
      return index.CDSNavReducerActionKind.CLOSE;
    } else if (e.type === 'click' || e.type === 'pointerdown') {
      const [clickId, clickItem] = Object.entries((navItemRefs === null || navItemRefs === void 0 ? void 0 : navItemRefs.current) || {}).find(([, clickItem]) => clickItem.contains(e.target)) || [null, null];
      if (clickId === id) {
        return index.CDSNavReducerActionKind.CLICK;
      } else if (clickItem) {
        // ignore the close event because a new menu is opening
        return null;
      }
      return index.CDSNavReducerActionKind.CLOSE;
    } else {
      switch (e === null || e === void 0 ? void 0 : e.type) {
        case 'mouseenter':
          return index.CDSNavReducerActionKind.HOVER;
        case 'mousemove':
          return index.CDSNavReducerActionKind.HOVER;
        case 'mouseleave':
          return index.CDSNavReducerActionKind.UNHOVER;
      }
    }
    return null;
  }, [id, navItemRefs]);
  const menuRect = (_a = floatingMenuPositionRef === null || floatingMenuPositionRef === void 0 ? void 0 : floatingMenuPositionRef.current) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect();
  const shiftMenu = () => ({
    name: 'shiftByAmount',
    options: [menuRect, isSubMenuOpen],
    fn: ({
      x,
      y,
      rects
    }) => {
      if (menuRect) {
        return {
          x: x + 16,
          y: menuRect.y,
          height: menuRect.height
        };
      }
      return {};
    }
  });
  const {
    refs,
    context,
    floatingStyles
  } = react$1.useFloating({
    open: isSubMenuOpen || isSubMenuAnimating,
    onOpenChange: (_, e) => {
      const action = getReducerActionFromFloatingEvent(e);
      if (action) {
        reducerDispatch === null || reducerDispatch === void 0 ? void 0 : reducerDispatch({
          type: action,
          payload: {
            id,
            menu: menu
          }
        });
      }
    },
    placement: 'right',
    strategy: 'fixed',
    transform: false,
    middleware: [shiftMenu(), react$1.size({
      apply: ({
        elements
      }) => {
        var _a;
        Object.assign(elements.floating.style, {
          height: `${(_a = menuRect === null || menuRect === void 0 ? void 0 : menuRect.height) !== null && _a !== void 0 ? _a : 0}px`
        });
      }
    })],
    whileElementsMounted: react$1.autoUpdate
  });
  const {
    getReferenceProps,
    getFloatingProps
  } = react$1.useInteractions([react$1.useHover(context, {
    handleClose: react$1.safePolygon({
      requireIntent: false
    }),
    delay: {
      open: reducerState.isOpen ? 0 : 400,
      close: 150
    }
  }), react$1.useClick(context), react$1.useDismiss(context, {
    referencePressEvent: 'click'
  })]);
  const componentProps = {
    'aria-expanded': !!isSubMenuOpen,
    'aria-controls': subMenuId
  };
  const classes = cdsComponentUtilities.cx(navItemWithSubmenu_module["default"], {
    'cds-nav__item--active': isSubMenuOpen
  }, className);
  const menuContainerClasses = cdsComponentUtilities.cx(navItemWithSubmenu_module["default"], 'cds-nav__menu-container', {
    'cds-nav__menu-container--open': isSubMenuOpen || isSubMenuAnimating,
    'cds-nav__menu-container--animating': isSubMenuAnimating
  });
  const itemMergeRef = cdsComponentTypes.useMergeRefs([ref, refs.setReference, element => {
    if (element && (navItemRefs === null || navItemRefs === void 0 ? void 0 : navItemRefs.current) && menu) {
      navItemRefs.current[id] = element;
    }
  }]);
  const navMenuContextValue = react.useMemo(() => ({
    itemName: children
  }), [children]);
  return jsxRuntime.jsx(navMenuContext.NavMenuContext.Provider, {
    value: navMenuContextValue,
    children: jsxRuntime.jsx(navItemBase.CDSNavItemBase, {
      ref: itemMergeRef,
      id: id,
      className: classes,
      as: 'button',
      icon: icon,
      canShowTooltip: !isSubMenuOpen && !isSubMenuAnimating,
      ...getReferenceProps({
        ...componentProps,
        ...rest
      }),
      canShowCaret: !!menu && !isSubMenuOpen,
      menu: (isSubMenuOpen || isSubMenuAnimating) && subMenuToShow ? jsxRuntime.jsx(react$1.FloatingFocusManager, {
        context: context,
        initialFocus: -1,
        modal: false,
        children: jsxRuntime.jsx("div", {
          className: menuContainerClasses,
          id: subMenuId,
          ...getFloatingProps(),
          ref: refs.setFloating,
          style: {
            ...floatingStyles
          },
          children: jsxRuntime.jsx(framerMotion.motion.div, {
            style: {
              display: 'block',
              height: '100%',
              translateX: floatingMenuAnimationX !== null && floatingMenuAnimationX !== void 0 ? floatingMenuAnimationX : 0,
              zIndex: reducerState.isAnimating ? -1 : 0
            },
            children: subMenuToShow
          })
        })
      }) : undefined,
      children: children
    })
  });
});
CDSNavItemWithSubMenu.displayName = 'CDSNav.Item.WithSubmenu';

exports.CDSNavItemWithSubMenu = CDSNavItemWithSubMenu;
exports["default"] = CDSNavItemWithSubMenu;
