import { forwardRef, useCallback, useMemo } from 'react';
import { useId, useFloating, size, autoUpdate, useInteractions, useHover, safePolygon, useClick, useDismiss, FloatingFocusManager } from '@floating-ui/react';
import { motion } from 'framer-motion';
import { useMergeRefs } from '@ciscodesignsystems/cds-component-types';
import { cx } from '@ciscodesignsystems/cds-component-utilities';
import { useNavContext } from '../../context/nav-context.esm.js';
import { NavMenuContext } from '../../context/nav-menu-context.esm.js';
import { CDSNavReducerActionKind } from '../../types/index.esm.js';
import { CDSNavItemBase } from './nav-item-base.esm.js';
import styles from './nav-item-with-submenu.module.esm.js';
import { jsx } from 'react/jsx-runtime';

const CDSNavItemWithSubMenu = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    menu,
    icon,
    children,
    className,
    onMouseEnter,
    onMouseLeave,
    ...rest
  } = props;
  const id = useId();
  const subMenuId = `cds-nav-submenu-${useId()}`;
  const {
    reducerState,
    reducerDispatch,
    floatingMenuAnimationX,
    floatingMenuPositionRef,
    navItemRefs
  } = useNavContext();
  const isSubMenuOpen = menu && reducerState.id === id && reducerState.isOpen;
  const isSubMenuAnimating = menu && reducerState.id === id && reducerState.isAnimating;
  const subMenuToShow = reducerState.subMenuStack.at(-1);
  const getReducerActionFromFloatingEvent = useCallback(e => {
    if (e === undefined) {
      return null;
    } else if (e.type === 'keydown' && e.key === 'Escape') {
      return CDSNavReducerActionKind.CLOSE;
    } else if (e.type === 'click' || e.type === 'pointerdown') {
      const [clickId, clickItem] = Object.entries(navItemRefs?.current || {}).find(([, clickItem]) => clickItem.contains(e.target)) || [null, null];
      if (clickId === id) {
        return CDSNavReducerActionKind.CLICK;
      } else if (clickItem) {
        // ignore the close event because a new menu is opening
        return null;
      }
      return CDSNavReducerActionKind.CLOSE;
    } else {
      switch (e?.type) {
        case 'mouseenter':
          return CDSNavReducerActionKind.HOVER;
        case 'mousemove':
          return CDSNavReducerActionKind.HOVER;
        case 'mouseleave':
          return CDSNavReducerActionKind.UNHOVER;
      }
    }
    return null;
  }, [id, navItemRefs]);
  const menuRect = floatingMenuPositionRef?.current?.getBoundingClientRect();
  const shiftMenu = () => ({
    name: 'shiftByAmount',
    options: [menuRect, isSubMenuOpen],
    fn: ({
      x,
      y,
      rects
    }) => {
      if (menuRect) {
        return {
          x: x + 16,
          //scss variable $cds-nav-padding
          y: menuRect.y,
          height: menuRect.height
        };
      }
      return {};
    }
  });
  const {
    refs,
    context,
    floatingStyles
  } = useFloating({
    open: isSubMenuOpen || isSubMenuAnimating,
    onOpenChange: (_, e) => {
      const action = getReducerActionFromFloatingEvent(e);
      if (action) {
        reducerDispatch?.({
          type: action,
          payload: {
            id,
            menu: menu
          }
        });
      }
    },
    placement: 'right',
    strategy: 'fixed',
    transform: false,
    middleware: [shiftMenu(), size({
      apply: ({
        elements
      }) => {
        Object.assign(elements.floating.style, {
          height: `${menuRect?.height ?? 0}px`
        });
      }
    })],
    whileElementsMounted: autoUpdate
  });
  const {
    getReferenceProps,
    getFloatingProps
  } = useInteractions([useHover(context, {
    handleClose: safePolygon({
      requireIntent: false
    }),
    delay: {
      open: reducerState.isOpen ? 0 : 400,
      close: 150
    }
  }), useClick(context), useDismiss(context, {
    referencePressEvent: 'click'
  })]);
  const componentProps = {
    'aria-expanded': !!isSubMenuOpen,
    'aria-controls': subMenuId
  };
  const classes = cx(styles, {
    'cds-nav__item--active': isSubMenuOpen
  }, className);
  const menuContainerClasses = cx(styles, 'cds-nav__menu-container', {
    'cds-nav__menu-container--open': isSubMenuOpen || isSubMenuAnimating,
    'cds-nav__menu-container--animating': isSubMenuAnimating
  });
  const itemMergeRef = useMergeRefs([ref, refs.setReference, element => {
    if (element && navItemRefs?.current && menu) {
      navItemRefs.current[id] = element;
    }
  }]);
  const navMenuContextValue = useMemo(() => ({
    itemName: children
  }), [children]);
  return /*#__PURE__*/jsx(NavMenuContext.Provider, {
    value: navMenuContextValue,
    children: /*#__PURE__*/jsx(CDSNavItemBase, {
      ref: itemMergeRef,
      id: id,
      className: classes,
      as: 'button',
      icon: icon,
      canShowTooltip: !isSubMenuOpen && !isSubMenuAnimating,
      ...getReferenceProps({
        ...componentProps,
        ...rest
      }),
      canShowCaret: !!menu && !isSubMenuOpen,
      menu: (isSubMenuOpen || isSubMenuAnimating) && subMenuToShow ? /*#__PURE__*/jsx(FloatingFocusManager, {
        context: context,
        initialFocus: -1,
        modal: false,
        children: /*#__PURE__*/jsx("div", {
          className: menuContainerClasses,
          id: subMenuId,
          ...getFloatingProps(),
          ref: refs.setFloating,
          style: {
            ...floatingStyles
          },
          children: /*#__PURE__*/jsx(motion.div, {
            style: {
              display: 'block',
              height: '100%',
              translateX: floatingMenuAnimationX ?? 0,
              zIndex: reducerState.isAnimating ? -1 : 0
            },
            children: subMenuToShow
          })
        })
      }) : undefined,
      children: children
    })
  });
});
CDSNavItemWithSubMenu.displayName = 'CDSNav.Item.WithSubmenu';

export { CDSNavItemWithSubMenu, CDSNavItemWithSubMenu as default };
