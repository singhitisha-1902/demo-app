'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var react = require('react');
var react$1 = require('@floating-ui/react');
var cdsComponentUtilities = require('@ciscodesignsystems/cds-component-utilities');
var useMenuInteractions = require('./use-menu-interactions.cjs.js');

const useMenu = ({
  open,
  onChange,
  defaultOpen
}) => {
  const [isOpen, setIsOpen] = cdsComponentUtilities.useControllableState({
    value: open,
    onChange: onChange,
    defaultValue: defaultOpen
  });
  const [activeIndex, setActiveIndex] = react.useState(null);
  const [allowHover, setAllowHover] = react.useState(false);
  const listItemsRef = react.useRef([]);
  const tree = react$1.useFloatingTree();
  const nodeId = react$1.useFloatingNodeId();
  const parentId = react$1.useFloatingParentNodeId();
  const isNested = parentId !== null;
  const {
    context,
    getFloatingProps,
    getItemProps,
    getReferenceProps,
    refs,
    strategy,
    x,
    y
  } = useMenuInteractions.useMenuInteractions({
    activeIndex,
    allowHover,
    isNested,
    isOpen,
    listItemsRef,
    nodeId,
    setActiveIndex,
    setIsOpen
  });
  // Event emitter allows you to communicate across tree components.
  // This effect closes all menus when an item gets clicked anywhere
  // in the tree.
  react.useEffect(() => {
    if (!tree) {
      return;
    }
    function handleTreeClick() {
      setIsOpen(false);
    }
    function onSubMenuOpen(event) {
      if (event.nodeId !== nodeId && event.parentId === parentId) {
        setIsOpen(false);
      }
    }
    tree.events.on('click', handleTreeClick);
    tree.events.on('menuopen', onSubMenuOpen);
    return () => {
      tree.events.off('click', handleTreeClick);
      tree.events.off('menuopen', onSubMenuOpen);
    };
  }, [tree, nodeId, parentId, setIsOpen]);
  react.useEffect(() => {
    if (isOpen && tree) {
      tree.events.emit('menuopen', {
        parentId,
        nodeId
      });
    }
  }, [tree, isOpen, nodeId, parentId]);
  // Determine if "hover" logic can run based on the modality of input. This
  // prevents unwanted focus synchronization as menus open and close with
  // keyboard navigation and the cursor is resting on the menu.
  react.useEffect(() => {
    function onPointerMove({
      pointerType
    }) {
      if (pointerType !== 'touch') {
        setAllowHover(true);
      }
    }
    function onKeyDown() {
      setAllowHover(false);
    }
    window.addEventListener('pointermove', onPointerMove, {
      once: true,
      capture: true
    });
    window.addEventListener('keydown', onKeyDown, true);
    return () => {
      window.removeEventListener('pointermove', onPointerMove, {
        capture: true
      });
      window.removeEventListener('keydown', onKeyDown, true);
    };
  }, [allowHover]);
  return {
    isOpen,
    activeIndex,
    setActiveIndex,
    allowHover,
    setAllowHover,
    listItemsRef,
    tree,
    nodeId,
    isNested,
    context,
    refs,
    strategy,
    x,
    y,
    getFloatingProps,
    getItemProps,
    getReferenceProps
  };
};

exports.useMenu = useMenu;
