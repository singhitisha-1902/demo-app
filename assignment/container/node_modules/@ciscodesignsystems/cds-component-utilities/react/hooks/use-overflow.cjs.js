'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var react = require('react');
var utils = require('@react-aria/utils');

const useOverflow = (children, childQuerySelector, offsetPadding) => {
  const childArray = react.Children.toArray(children);
  const ref = react.useRef(null);
  const [visibleItems, setVisibleItems] = utils.useValueEffect(childArray.length);
  const updateOverflow = react.useCallback(() => {
    const computeVisibleItems = visibleItems => {
      var _a;
      const currListRef = ref.current;
      // return full length of children if ref is not set
      if (!currListRef) {
        return childArray.length;
      }
      const containerOffsetPadding = offsetPadding;
      // Array of all items
      const [firstItem, ...listItems] = Array.from(currListRef.querySelectorAll(childQuerySelector));
      const containerWidth = currListRef.offsetWidth - containerOffsetPadding;
      const hasEllipsis = childArray.length > visibleItems;
      let calculatedWidth = 0;
      let updatedVisibleItems = 0;
      // Get initial item outside of loop, we should always show at least two
      calculatedWidth += (firstItem === null || firstItem === void 0 ? void 0 : firstItem.scrollWidth) || 0;
      updatedVisibleItems++;
      // If the ellipsis is shown, account for the width without adding a visible item
      if (hasEllipsis) {
        calculatedWidth += ((_a = listItems.pop()) === null || _a === void 0 ? void 0 : _a.scrollWidth) || 0;
        updatedVisibleItems--;
      }
      if (calculatedWidth >= containerWidth) {
        updatedVisibleItems--;
      }
      // Iterate through items backward, adding their scroll width to the calculated width until the container width is full.
      for (const {
        scrollWidth
      } of listItems) {
        calculatedWidth += scrollWidth;
        if (calculatedWidth < containerWidth) {
          updatedVisibleItems++;
        }
      }
      return updatedVisibleItems;
    };
    setVisibleItems(function* () {
      yield childArray.length;
      const updatedVisibleItems = computeVisibleItems(childArray.length);
      yield updatedVisibleItems;
      if (updatedVisibleItems < childArray.length) {
        yield computeVisibleItems(updatedVisibleItems);
      }
    });
  }, [childArray.length, childQuerySelector, offsetPadding, setVisibleItems]);
  utils.useResizeObserver({
    ref: ref,
    onResize: updateOverflow
  });
  react.useLayoutEffect(updateOverflow, [updateOverflow]);
  return {
    visibleItems,
    childArray,
    ref
  };
};

exports.useOverflow = useOverflow;
