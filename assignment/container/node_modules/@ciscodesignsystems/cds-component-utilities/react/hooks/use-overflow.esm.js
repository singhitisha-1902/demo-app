import { Children, useRef, useCallback, useLayoutEffect } from 'react';
import { useValueEffect, useResizeObserver } from '@react-aria/utils';

const useOverflow = (children, childQuerySelector, offsetPadding) => {
  const childArray = Children.toArray(children);
  const ref = useRef(null);
  const [visibleItems, setVisibleItems] = useValueEffect(childArray.length);
  const updateOverflow = useCallback(() => {
    const computeVisibleItems = visibleItems => {
      const currListRef = ref.current;

      // return full length of children if ref is not set
      if (!currListRef) {
        return childArray.length;
      }
      const containerOffsetPadding = offsetPadding;
      // Array of all items
      const [firstItem, ...listItems] = Array.from(currListRef.querySelectorAll(childQuerySelector));
      const containerWidth = currListRef.offsetWidth - containerOffsetPadding;
      const hasEllipsis = childArray.length > visibleItems;
      let calculatedWidth = 0;
      let updatedVisibleItems = 0;

      // Get initial item outside of loop, we should always show at least two
      calculatedWidth += firstItem?.scrollWidth || 0;
      updatedVisibleItems++;

      // If the ellipsis is shown, account for the width without adding a visible item
      if (hasEllipsis) {
        calculatedWidth += listItems.pop()?.scrollWidth || 0;
        updatedVisibleItems--;
      }
      if (calculatedWidth >= containerWidth) {
        updatedVisibleItems--;
      }

      // Iterate through items backward, adding their scroll width to the calculated width until the container width is full.
      for (const {
        scrollWidth
      } of listItems) {
        calculatedWidth += scrollWidth;
        if (calculatedWidth < containerWidth) {
          updatedVisibleItems++;
        }
      }
      return updatedVisibleItems;
    };
    setVisibleItems(function* () {
      yield childArray.length;
      const updatedVisibleItems = computeVisibleItems(childArray.length);
      yield updatedVisibleItems;
      if (updatedVisibleItems < childArray.length) {
        yield computeVisibleItems(updatedVisibleItems);
      }
    });
  }, [childArray.length, childQuerySelector, offsetPadding, setVisibleItems]);
  useResizeObserver({
    ref: ref,
    onResize: updateOverflow
  });
  useLayoutEffect(updateOverflow, [updateOverflow]);
  return {
    visibleItems,
    childArray,
    ref
  };
};

export { useOverflow };
